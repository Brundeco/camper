{"version":3,"sources":["jquery.validationEngine-nl.js","jquery.validationEngine.js","googlemaps-styles.js","contact.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClgEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"contact.js","sourcesContent":["(function($){\n\t$.fn.validationEngineLanguage = function(){\n\t};\n\t$.validationEngineLanguage = {\n\t    newLang: function(){\n\t        $.validationEngineLanguage.allRules = {\n\t            \"required\": { // Add your regex rules here, you can take telephone as an example\n\t                \"regex\": \"geen\",\n\t                \"alertText\": \"* Dit veld is verplicht\",\n\t                \"alertTextCheckboxMultiple\": \"* Selecteer a.u.b. een optie\",\n\t                \"alertTextCheckboxe\": \"* Dit selectievakje is verplicht\"\n\t            },\n\t            \"requiredInFunction\": { \n                    \"func\": function(field, rules, i, options){\n                        return (field.val() == \"test\") ? true : false;\n                    },\n                    \"alertText\": \"* Field must equal test\"\n                \t    },\n\t            \"minSize\": {\n\t                \"regex\": \"none\",\n\t                \"alertText\": \"* Minimaal \",\n\t                \"alertText2\": \" karakters toegestaan\"\n\t            },\n\t            \"maxSize\": {\n\t                \"regex\": \"none\",\n\t                \"alertText\": \"* Maximaal \",\n\t                \"alertText2\": \" karakters toegestaan\"\n\t            },\n\t\t\t\t\"groupRequired\": {\n                    \"regex\": \"none\",\n                    \"alertText\": \"* You must fill one of the following fields\"\n                },\n\t            \"min\": {\n\t                \"regex\": \"none\",\n\t                \"alertText\": \"* Minimale waarde is \"\n\t            },\n\t            \"max\": {\n\t                \"regex\": \"none\",\n\t                \"alertText\": \"* Maximale waarde is \"\n\t            },\n\t            \"past\": {\n\t                \"regex\": \"none\",\n\t                \"alertText\": \"* Datum voorafgaand aan \"\n\t            },\n\t            \"future\": {\n\t                \"regex\": \"none\",\n\t                \"alertText\": \"* Datum na \"\n\t            },\n\t            \"maxCheckbox\": {\n\t                \"regex\": \"none\",\n\t                \"alertText\": \"* Toegestane aantal vinkjes overschreden\"\n\t            },\n\t            \"minCheckbox\": {\n\t                \"regex\": \"none\",\n\t                \"alertText\": \"* Selecteer a.u.b. \",\n\t                \"alertText2\": \" opties\"\n\t            },\n\t            \"equals\": {\n\t                \"regex\": \"none\",\n\t                \"alertText\": \"* Velden komen niet overeen\"\n\t            },\n                \"creditCard\": {\n                    \"regex\": \"none\",\n                    \"alertText\": \"* Ongeldige credit card nummer\"\n                },\n\t            \"phone\": {\n\t                // credit: jquery.h5validate.js / orefalo\n\t                \"regex\": /^\\+?([\\+][0-9]{1,3}[ \\.\\-])?([\\(]{1}[0-9]{2,6}[\\)])?([0-9 \\.\\-\\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,\n\t                \"alertText\": \"* Ongeldig telefoonnummer\"\n\t            },\n\t            \"email\": {\n\t                // Shamelessly lifted from Scott Gonzalez via the Bassistance Validation plugin http://projects.scottsplayground.com/email_address_validation/\n\t                \"regex\": /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?$/i,\n\t                \"alertText\": \"* Ongeldig e-mailadres\"\n\t            },\n\t            \"integer\": {\n\t                \"regex\": /^[\\-\\+]?\\d+$/,\n\t                \"alertText\": \"* Ongeldig geheel getal\"\n\t            },\n\t            \"number\": {\n\t                // Number, including positive, negative, and floating decimal. credit: orefalo\n\t                \"regex\": /^[\\-\\+]?(([0-9]+)([\\.,]([0-9]+))?|([\\.,]([0-9]+))?)$/,\n\t                \"alertText\": \"* Ongeldig drijvende comma getal\"\n\t            },\n\t            \"date\": {\n\t                \"regex\": /^\\d{4}[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])$/,\n\t                \"alertText\": \"* Ongeldige datum, formaat moet JJJJ-MM-DD zijn\"\n\t            },\n\t            \"ipv4\": {\n\t            \t\"regex\": /^((([01]?[0-9]{1,2})|(2[0-4][0-9])|(25[0-5]))[.]){3}(([0-1]?[0-9]{1,2})|(2[0-4][0-9])|(25[0-5]))$/,\n\t                \"alertText\": \"* Ongeldig IP-adres\"\n\t            },\n\t            \"url\": {\n                    \"regex\": /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i,\n\t                \"alertText\": \"* Ongeldige URL\"\n\t            },\n\t            \"onlyNumberSp\": {\n\t                \"regex\": /^[0-9\\ ]+$/,\n\t                \"alertText\": \"* Alleen cijfers\"\n\t            },\n\t            \"onlyLetterSp\": {\n\t                \"regex\": /^[a-zA-Z\\ \\']+$/,\n\t                \"alertText\": \"* Alleen leestekens\"\n\t            },\n\t            \"onlyLetterNumber\": {\n\t                \"regex\": /^[0-9a-zA-Z]+$/,\n\t                \"alertText\": \"* Geen vreemde tekens toegestaan\"\n\t            },\n\t            // --- CUSTOM RULES -- Those are specific to the demos, they can be removed or changed to your likings\n\t            \"ajaxUserCall\": {\n\t                \"url\": \"ajaxValidateFieldUser\",\n\t                // you may want to pass extra data on the ajax call\n\t                \"extraData\": \"name=eric\",\n\t                \"alertText\": \"* Deze gebruiker bestaat al\",\n\t                \"alertTextLoad\": \"* Bezig met valideren, even geduld aub\"\n\t            },\n\t            \"ajaxNameCall\": {\n\t                // remote json service location\n\t                \"url\": \"ajaxValidateFieldName\",\n\t                // error\n\t                \"alertText\": \"* Deze naam bestaat al\",\n\t                // if you provide an \"alertTextOk\", it will show as a green prompt when the field validates\n\t                \"alertTextOk\": \"* Deze naam is beschikbaar\",\n\t                // speaks by itself\n\t                \"alertTextLoad\": \"* Bezig met valideren, even geduld aub\"\n\t            },\n\t            \"validate2fields\": {\n\t                \"alertText\": \"* Voer aub HELLO in\"\n\t            }\n\t        };\n\n\t    }\n\t};\n\t$.validationEngineLanguage.newLang();\n})(jQuery);\n\n","/*\r\n * Inline Form Validation Engine 2.6.2, jQuery plugin\r\n *\r\n * Copyright(c) 2010, Cedric Dugas\r\n * http://www.position-absolute.com\r\n *\r\n * 2.0 Rewrite by Olivier Refalo\r\n * http://www.crionics.com\r\n *\r\n * Form validation engine allowing custom regex rules to be added.\r\n * Licensed under the MIT License\r\n */\r\n (function($) {\r\n\r\n\t\"use strict\";\r\n\r\n\tvar methods = {\r\n\r\n\t\t/**\r\n\t\t* Kind of the constructor, called before any action\r\n\t\t* @param {Map} user options\r\n\t\t*/\r\n\t\tinit: function(options) {\r\n\t\t\tvar form = this;\r\n\t\t\tif (!form.data('jqv') || form.data('jqv') == null ) {\r\n\t\t\t\toptions = methods._saveOptions(form, options);\r\n\t\t\t\t// bind all formError elements to close on click\r\n\t\t\t\t$(document).on(\"click\", \".formError\", function() {\r\n\t\t\t\t\t$(this).fadeOut(150, function() {\r\n\t\t\t\t\t\t// remove prompt once invisible\r\n\t\t\t\t\t\t$(this).parent('.formErrorOuter').remove();\r\n\t\t\t\t\t\t$(this).remove();\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t },\r\n\t\t/**\r\n\t\t* Attachs jQuery.validationEngine to form.submit and field.blur events\r\n\t\t* Takes an optional params: a list of options\r\n\t\t* ie. jQuery(\"#formID1\").validationEngine('attach', {promptPosition : \"centerRight\"});\r\n\t\t*/\r\n\t\tattach: function(userOptions) {\r\n\r\n\t\t\tvar form = this;\r\n\t\t\tvar options;\r\n\r\n\t\t\tif(userOptions)\r\n\t\t\t\toptions = methods._saveOptions(form, userOptions);\r\n\t\t\telse\r\n\t\t\t\toptions = form.data('jqv');\r\n\r\n\t\t\toptions.validateAttribute = (form.find(\"[data-validation-engine*=validate]\").length) ? \"data-validation-engine\" : \"class\";\r\n\t\t\tif (options.binded) {\r\n\r\n\t\t\t\t// delegate fields\r\n\t\t\t\tform.on(options.validationEventTrigger, \"[\"+options.validateAttribute+\"*=validate]:not([type=checkbox]):not([type=radio]):not(.datepicker)\", methods._onFieldEvent);\r\n\t\t\t\tform.on(\"click\", \"[\"+options.validateAttribute+\"*=validate][type=checkbox],[\"+options.validateAttribute+\"*=validate][type=radio]\", methods._onFieldEvent);\r\n\t\t\t\tform.on(options.validationEventTrigger,\"[\"+options.validateAttribute+\"*=validate][class*=datepicker]\", {\"delay\": 300}, methods._onFieldEvent);\r\n\t\t\t}\r\n\t\t\tif (options.autoPositionUpdate) {\r\n\t\t\t\t$(window).bind(\"resize\", {\r\n\t\t\t\t\t\"noAnimation\": true,\r\n\t\t\t\t\t\"formElem\": form\r\n\t\t\t\t}, methods.updatePromptsPosition);\r\n\t\t\t}\r\n\t\t\tform.on(\"click\",\"a[data-validation-engine-skip], a[class*='validate-skip'], button[data-validation-engine-skip], button[class*='validate-skip'], input[data-validation-engine-skip], input[class*='validate-skip']\", methods._submitButtonClick);\r\n\t\t\tform.removeData('jqv_submitButton');\r\n\r\n\t\t\t// bind form.submit\r\n\t\t\tform.on(\"submit\", methods._onSubmitEvent);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t/**\r\n\t\t* Unregisters any bindings that may point to jQuery.validaitonEngine\r\n\t\t*/\r\n\t\tdetach: function() {\r\n\r\n\t\t\tvar form = this;\r\n\t\t\tvar options = form.data('jqv');\r\n\r\n\t\t\t// unbind fields\r\n\t\t\tform.find(\"[\"+options.validateAttribute+\"*=validate]\").not(\"[type=checkbox]\").off(options.validationEventTrigger, methods._onFieldEvent);\r\n\t\t\tform.find(\"[\"+options.validateAttribute+\"*=validate][type=checkbox],[class*=validate][type=radio]\").off(\"click\", methods._onFieldEvent);\r\n\r\n\t\t\t// unbind form.submit\r\n\t\t\tform.off(\"submit\", methods.onAjaxFormComplete);\r\n\r\n\t\t\t// unbind form.submit\r\n\t\t\tform.off(\"submit\", methods.onAjaxFormComplete);\r\n\t\t\tform.removeData('jqv');\r\n            \r\n\t\t\tform.off(\"click\", \"a[data-validation-engine-skip], a[class*='validate-skip'], button[data-validation-engine-skip], button[class*='validate-skip'], input[data-validation-engine-skip], input[class*='validate-skip']\", methods._submitButtonClick);\r\n\t\t\tform.removeData('jqv_submitButton');\r\n\r\n\t\t\tif (options.autoPositionUpdate)\r\n\t\t\t\t$(window).unbind(\"resize\", methods.updatePromptsPosition);\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t/**\r\n\t\t* Validates either a form or a list of fields, shows prompts accordingly.\r\n\t\t* Note: There is no ajax form validation with this method, only field ajax validation are evaluated\r\n\t\t*\r\n\t\t* @return true if the form validates, false if it fails\r\n\t\t*/\r\n\t\tvalidate: function() {\r\n\t\t\tvar element = $(this);\r\n\t\t\tvar valid = null;\r\n\r\n\t\t\tif (element.is(\"form\") || element.hasClass(\"validationEngineContainer\")) {\r\n\t\t\t\tif (element.hasClass('validating')) {\r\n\t\t\t\t\t// form is already validating.\r\n\t\t\t\t\t// Should abort old validation and start new one. I don't know how to implement it.\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} else {\t\t\t\t\r\n\t\t\t\t\telement.addClass('validating');\r\n\t\t\t\t\tvar options = element.data('jqv');\r\n\t\t\t\t\tvar valid = methods._validateFields(this);\r\n\r\n\t\t\t\t\t// If the form doesn't validate, clear the 'validating' class before the user has a chance to submit again\r\n\t\t\t\t\tsetTimeout(function(){\r\n\t\t\t\t\t\telement.removeClass('validating');\r\n\t\t\t\t\t}, 100);\r\n\t\t\t\t\tif (valid && options.onSuccess) {\r\n\t\t\t\t\t\toptions.onSuccess();\r\n\t\t\t\t\t} else if (!valid && options.onFailure) {\r\n\t\t\t\t\t\toptions.onFailure();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (element.is('form') || element.hasClass('validationEngineContainer')) {\r\n\t\t\t\telement.removeClass('validating');\r\n\t\t\t} else {\r\n\t\t\t\t// field validation\r\n\t\t\t\tvar form = element.closest('form, .validationEngineContainer'),\r\n\t\t\t\t\toptions = (form.data('jqv')) ? form.data('jqv') : $.validationEngine.defaults,\r\n\t\t\t\t\tvalid = methods._validateField(element, options);\r\n\r\n\t\t\t\tif (valid && options.onFieldSuccess)\r\n\t\t\t\t\toptions.onFieldSuccess();\r\n\t\t\t\telse if (options.onFieldFailure && options.InvalidFields.length > 0) {\r\n\t\t\t\t\toptions.onFieldFailure();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(options.onValidationComplete) {\r\n\t\t\t\t// !! ensures that an undefined return is interpreted as return false but allows a onValidationComplete() to possibly return true and have form continue processing\r\n\t\t\t\treturn !!options.onValidationComplete(form, valid);\r\n\t\t\t}\r\n\t\t\treturn valid;\r\n\t\t},\r\n\t\t/**\r\n\t\t*  Redraw prompts position, useful when you change the DOM state when validating\r\n\t\t*/\r\n\t\tupdatePromptsPosition: function(event) {\r\n\r\n\t\t\tif (event && this == window) {\r\n\t\t\t\tvar form = event.data.formElem;\r\n\t\t\t\tvar noAnimation = event.data.noAnimation;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tvar form = $(this.closest('form, .validationEngineContainer'));\r\n\r\n\t\t\tvar options = form.data('jqv');\r\n\t\t\t// No option, take default one\r\n\t\t\tform.find('['+options.validateAttribute+'*=validate]').not(\":disabled\").each(function(){\r\n\t\t\t\tvar field = $(this);\r\n\t\t\t\tif (options.prettySelect && field.is(\":hidden\"))\r\n\t\t\t\t  field = form.find(\"#\" + options.usePrefix + field.attr('id') + options.useSuffix);\r\n\t\t\t\tvar prompt = methods._getPrompt(field);\r\n\t\t\t\tvar promptText = $(prompt).find(\".formErrorContent\").html();\r\n\r\n\t\t\t\tif(prompt)\r\n\t\t\t\t\tmethods._updatePrompt(field, $(prompt), promptText, undefined, false, options, noAnimation);\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t/**\r\n\t\t* Displays a prompt on a element.\r\n\t\t* Note that the element needs an id!\r\n\t\t*\r\n\t\t* @param {String} promptText html text to display type\r\n\t\t* @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)\r\n\t\t* @param {String} possible values topLeft, topRight, bottomLeft, centerRight, bottomRight\r\n\t\t*/\r\n\t\tshowPrompt: function(promptText, type, promptPosition, showArrow) {\r\n\t\t\tvar form = this.closest('form, .validationEngineContainer');\r\n\t\t\tvar options = form.data('jqv');\r\n\t\t\t// No option, take default one\r\n\t\t\tif(!options)\r\n\t\t\t\toptions = methods._saveOptions(this, options);\r\n\t\t\tif(promptPosition)\r\n\t\t\t\toptions.promptPosition=promptPosition;\r\n\t\t\toptions.showArrow = showArrow==true;\r\n\r\n\t\t\tmethods._showPrompt(this, promptText, type, false, options);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t/**\r\n\t\t* Closes form error prompts, CAN be invidual\r\n\t\t*/\r\n\t\thide: function() {\r\n\t\t\t var form = $(this).closest('form, .validationEngineContainer');\r\n\t\t\t var options = form.data('jqv');\r\n\t\t\t var fadeDuration = (options && options.fadeDuration) ? options.fadeDuration : 0.3;\r\n\t\t\t var closingtag;\r\n\t\t\t \r\n\t\t\t if($(this).is(\"form\") || $(this).hasClass(\"validationEngineContainer\")) {\r\n\t\t\t\t closingtag = \"parentForm\"+methods._getClassName($(this).attr(\"id\"));\r\n\t\t\t } else {\r\n\t\t\t\t closingtag = methods._getClassName($(this).attr(\"id\")) +\"formError\";\r\n\t\t\t }\r\n\t\t\t $('.'+closingtag).fadeTo(fadeDuration, 0.3, function() {\r\n\t\t\t\t $(this).parent('.formErrorOuter').remove();\r\n\t\t\t\t $(this).remove();\r\n\t\t\t });\r\n\t\t\t return this;\r\n\t\t },\r\n\t\t /**\r\n\t\t * Closes all error prompts on the page\r\n\t\t */\r\n\t\t hideAll: function() {\r\n\r\n\t\t\t var form = this;\r\n\t\t\t var options = form.data('jqv');\r\n\t\t\t var duration = options ? options.fadeDuration:300;\r\n\t\t\t $('.formError').fadeTo(duration, 300, function() {\r\n\t\t\t\t $(this).parent('.formErrorOuter').remove();\r\n\t\t\t\t $(this).remove();\r\n\t\t\t });\r\n\t\t\t return this;\r\n\t\t },\r\n\t\t/**\r\n\t\t* Typically called when user exists a field using tab or a mouse click, triggers a field\r\n\t\t* validation\r\n\t\t*/\r\n\t\t_onFieldEvent: function(event) {\r\n\t\t\tvar field = $(this);\r\n\t\t\tvar form = field.closest('form, .validationEngineContainer');\r\n\t\t\tvar options = form.data('jqv');\r\n\t\t\toptions.eventTrigger = \"field\";\r\n\t\t\t// validate the current field\r\n\t\t\twindow.setTimeout(function() {\r\n\t\t\t\tmethods._validateField(field, options);\r\n\t\t\t\tif (options.InvalidFields.length == 0 && options.onFieldSuccess) {\r\n\t\t\t\t\toptions.onFieldSuccess();\r\n\t\t\t\t} else if (options.InvalidFields.length > 0 && options.onFieldFailure) {\r\n\t\t\t\t\toptions.onFieldFailure();\r\n\t\t\t\t}\r\n\t\t\t}, (event.data) ? event.data.delay : 0);\r\n\r\n\t\t},\r\n\t\t/**\r\n\t\t* Called when the form is submited, shows prompts accordingly\r\n\t\t*\r\n\t\t* @param {jqObject}\r\n\t\t*            form\r\n\t\t* @return false if form submission needs to be cancelled\r\n\t\t*/\r\n\t\t_onSubmitEvent: function() {\r\n\t\t\tvar form = $(this);\r\n\t\t\tvar options = form.data('jqv');\r\n\t\t\t\r\n\t\t\t//check if it is trigger from skipped button\r\n\t\t\tif (form.data(\"jqv_submitButton\")){\r\n\t\t\t\tvar submitButton = $(\"#\" + form.data(\"jqv_submitButton\"));\r\n\t\t\t\tif (submitButton){\r\n\t\t\t\t\tif (submitButton.length > 0){\r\n\t\t\t\t\t\tif (submitButton.hasClass(\"validate-skip\") || submitButton.attr(\"data-validation-engine-skip\") == \"true\")\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\toptions.eventTrigger = \"submit\";\r\n\r\n\t\t\t// validate each field \r\n\t\t\t// (- skip field ajax validation, not necessary IF we will perform an ajax form validation)\r\n\t\t\tvar r=methods._validateFields(form);\r\n\r\n\t\t\tif (r && options.ajaxFormValidation) {\r\n\t\t\t\tmethods._validateFormWithAjax(form, options);\r\n\t\t\t\t// cancel form auto-submission - process with async call onAjaxFormComplete\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif(options.onValidationComplete) {\r\n\t\t\t\t// !! ensures that an undefined return is interpreted as return false but allows a onValidationComplete() to possibly return true and have form continue processing\r\n\t\t\t\treturn !!options.onValidationComplete(form, r);\r\n\t\t\t}\r\n\t\t\treturn r;\r\n\t\t},\r\n\t\t/**\r\n\t\t* Return true if the ajax field validations passed so far\r\n\t\t* @param {Object} options\r\n\t\t* @return true, is all ajax validation passed so far (remember ajax is async)\r\n\t\t*/\r\n\t\t_checkAjaxStatus: function(options) {\r\n\t\t\tvar status = true;\r\n\t\t\t$.each(options.ajaxValidCache, function(key, value) {\r\n\t\t\t\tif (!value) {\r\n\t\t\t\t\tstatus = false;\r\n\t\t\t\t\t// break the each\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn status;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t* Return true if the ajax field is validated\r\n\t\t* @param {String} fieldid\r\n\t\t* @param {Object} options\r\n\t\t* @return true, if validation passed, false if false or doesn't exist\r\n\t\t*/\r\n\t\t_checkAjaxFieldStatus: function(fieldid, options) {\r\n\t\t\treturn options.ajaxValidCache[fieldid] == true;\r\n\t\t},\r\n\t\t/**\r\n\t\t* Validates form fields, shows prompts accordingly\r\n\t\t*\r\n\t\t* @param {jqObject}\r\n\t\t*            form\r\n\t\t* @param {skipAjaxFieldValidation}\r\n\t\t*            boolean - when set to true, ajax field validation is skipped, typically used when the submit button is clicked\r\n\t\t*\r\n\t\t* @return true if form is valid, false if not, undefined if ajax form validation is done\r\n\t\t*/\r\n\t\t_validateFields: function(form) {\r\n\t\t\tvar options = form.data('jqv');\r\n\r\n\t\t\t// this variable is set to true if an error is found\r\n\t\t\tvar errorFound = false;\r\n\r\n\t\t\t// Trigger hook, start validation\r\n\t\t\tform.trigger(\"jqv.form.validating\");\r\n\t\t\t// first, evaluate status of non ajax fields\r\n\t\t\tvar first_err=null;\r\n\t\t\tform.find('['+options.validateAttribute+'*=validate]').not(\":disabled\").each( function() {\r\n\t\t\t\tvar field = $(this);\r\n\t\t\t\tvar names = [];\r\n\t\t\t\tif ($.inArray(field.attr('name'), names) < 0) {\r\n\t\t\t\t\terrorFound |= methods._validateField(field, options);\r\n\t\t\t\t\tif (errorFound && first_err==null)\r\n\t\t\t\t\t\tif (field.is(\":hidden\") && options.prettySelect)\r\n\t\t\t\t\t\t\t\t\t\t first_err = field = form.find(\"#\" + options.usePrefix + methods._jqSelector(field.attr('id')) + options.useSuffix);\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t first_err=field;\r\n\t\t\t\t\tif (options.doNotShowAllErrosOnSubmit)\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\tnames.push(field.attr('name'));\r\n\r\n\t\t\t\t\t//if option set, stop checking validation rules after one error is found\r\n\t\t\t\t\tif(options.showOneMessage == true && errorFound){\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// second, check to see if all ajax calls completed ok\r\n\t\t\t// errorFound |= !methods._checkAjaxStatus(options);\r\n\r\n\t\t\t// third, check status and scroll the container accordingly\r\n\t\t\tform.trigger(\"jqv.form.result\", [errorFound]);\r\n\r\n\t\t\tif (errorFound) {\r\n\t\t\t\tif (options.scroll) {\r\n\t\t\t\t\tvar destination=first_err.offset().top;\r\n\t\t\t\t\tvar fixleft = first_err.offset().left;\r\n\r\n\t\t\t\t\t//prompt positioning adjustment support. Usage: positionType:Xshift,Yshift (for ex.: bottomLeft:+20 or bottomLeft:-20,+10)\r\n\t\t\t\t\tvar positionType=options.promptPosition;\r\n\t\t\t\t\tif (typeof(positionType)=='string' && positionType.indexOf(\":\")!=-1)\r\n\t\t\t\t\t\tpositionType=positionType.substring(0,positionType.indexOf(\":\"));\r\n\r\n\t\t\t\t\tif (positionType!=\"bottomRight\" && positionType!=\"bottomLeft\") {\r\n\t\t\t\t\t\tvar prompt_err= methods._getPrompt(first_err);\r\n\t\t\t\t\t\tif (prompt_err) {\r\n\t\t\t\t\t\t\tdestination=prompt_err.offset().top;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Offset the amount the page scrolls by an amount in px to accomodate fixed elements at top of page\r\n\t\t\t\t\tif (options.scrollOffset) {\r\n\t\t\t\t\t\tdestination -= options.scrollOffset;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// get the position of the first error, there should be at least one, no need to check this\r\n\t\t\t\t\t//var destination = form.find(\".formError:not('.greenPopup'):first\").offset().top;\r\n\t\t\t\t\tif (options.isOverflown) {\r\n\t\t\t\t\t\tvar overflowDIV = $(options.overflownDIV);\r\n\t\t\t\t\t\tif(!overflowDIV.length) return false;\r\n\t\t\t\t\t\tvar scrollContainerScroll = overflowDIV.scrollTop();\r\n\t\t\t\t\t\tvar scrollContainerPos = -parseInt(overflowDIV.offset().top);\r\n\r\n\t\t\t\t\t\tdestination += scrollContainerScroll + scrollContainerPos - 5;\r\n\t\t\t\t\t\tvar scrollContainer = $(options.overflownDIV + \":not(:animated)\");\r\n\r\n\t\t\t\t\t\tscrollContainer.animate({ scrollTop: destination }, 1100, function(){\r\n\t\t\t\t\t\t\tif(options.focusFirstField) first_err.focus();\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$(\"html, body\").animate({\r\n\t\t\t\t\t\t\tscrollTop: destination\r\n\t\t\t\t\t\t}, 1100, function(){\r\n\t\t\t\t\t\t\tif(options.focusFirstField) first_err.focus();\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\t$(\"html, body\").animate({scrollLeft: fixleft},1100)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if(options.focusFirstField)\r\n\t\t\t\t\tfirst_err.focus();\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\t/**\r\n\t\t* This method is called to perform an ajax form validation.\r\n\t\t* During this process all the (field, value) pairs are sent to the server which returns a list of invalid fields or true\r\n\t\t*\r\n\t\t* @param {jqObject} form\r\n\t\t* @param {Map} options\r\n\t\t*/\r\n\t\t_validateFormWithAjax: function(form, options) {\r\n\r\n\t\t\tvar data = form.serialize();\r\n\t\t\t\t\t\t\t\t\tvar type = (options.ajaxFormValidationMethod) ? options.ajaxFormValidationMethod : \"GET\";\r\n\t\t\tvar url = (options.ajaxFormValidationURL) ? options.ajaxFormValidationURL : form.attr(\"action\");\r\n\t\t\t\t\t\t\t\t\tvar dataType = (options.dataType) ? options.dataType : \"json\";\r\n\t\t\t$.ajax({\r\n\t\t\t\ttype: type,\r\n\t\t\t\turl: url,\r\n\t\t\t\tcache: false,\r\n\t\t\t\tdataType: dataType,\r\n\t\t\t\tdata: data,\r\n\t\t\t\tform: form,\r\n\t\t\t\tmethods: methods,\r\n\t\t\t\toptions: options,\r\n\t\t\t\tbeforeSend: function() {\r\n\t\t\t\t\treturn options.onBeforeAjaxFormValidation(form, options);\r\n\t\t\t\t},\r\n\t\t\t\terror: function(data, transport) {\r\n\t\t\t\t\tmethods._ajaxError(data, transport);\r\n\t\t\t\t},\r\n\t\t\t\tsuccess: function(json) {\r\n\t\t\t\t\tif ((dataType == \"json\") && (json !== true)) {\r\n\t\t\t\t\t\t// getting to this case doesn't necessary means that the form is invalid\r\n\t\t\t\t\t\t// the server may return green or closing prompt actions\r\n\t\t\t\t\t\t// this flag helps figuring it out\r\n\t\t\t\t\t\tvar errorInForm=false;\r\n\t\t\t\t\t\tfor (var i = 0; i < json.length; i++) {\r\n\t\t\t\t\t\t\tvar value = json[i];\r\n\r\n\t\t\t\t\t\t\tvar errorFieldId = value[0];\r\n\t\t\t\t\t\t\tvar errorField = $($(\"#\" + errorFieldId)[0]);\r\n\r\n\t\t\t\t\t\t\t// make sure we found the element\r\n\t\t\t\t\t\t\tif (errorField.length == 1) {\r\n\r\n\t\t\t\t\t\t\t\t// promptText or selector\r\n\t\t\t\t\t\t\t\tvar msg = value[2];\r\n\t\t\t\t\t\t\t\t// if the field is valid\r\n\t\t\t\t\t\t\t\tif (value[1] == true) {\r\n\r\n\t\t\t\t\t\t\t\t\tif (msg == \"\"  || !msg){\r\n\t\t\t\t\t\t\t\t\t\t// if for some reason, status==true and error=\"\", just close the prompt\r\n\t\t\t\t\t\t\t\t\t\tmethods._closePrompt(errorField);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t// the field is valid, but we are displaying a green prompt\r\n\t\t\t\t\t\t\t\t\t\tif (options.allrules[msg]) {\r\n\t\t\t\t\t\t\t\t\t\t\tvar txt = options.allrules[msg].alertTextOk;\r\n\t\t\t\t\t\t\t\t\t\t\tif (txt)\r\n\t\t\t\t\t\t\t\t\t\t\t\tmsg = txt;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (options.showPrompts) methods._showPrompt(errorField, msg, \"pass\", false, options, true);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// the field is invalid, show the red error prompt\r\n\t\t\t\t\t\t\t\t\terrorInForm|=true;\r\n\t\t\t\t\t\t\t\t\tif (options.allrules[msg]) {\r\n\t\t\t\t\t\t\t\t\t\tvar txt = options.allrules[msg].alertText;\r\n\t\t\t\t\t\t\t\t\t\tif (txt)\r\n\t\t\t\t\t\t\t\t\t\t\tmsg = txt;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif(options.showPrompts) methods._showPrompt(errorField, msg, \"\", false, options, true);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toptions.onAjaxFormComplete(!errorInForm, form, json, options);\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\toptions.onAjaxFormComplete(true, form, json, options);\r\n\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t},\r\n\t\t/**\r\n\t\t* Validates field, shows prompts accordingly\r\n\t\t*\r\n\t\t* @param {jqObject}\r\n\t\t*            field\r\n\t\t* @param {Array[String]}\r\n\t\t*            field's validation rules\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return false if field is valid (It is inversed for *fields*, it return false on validate and true on errors.)\r\n\t\t*/\r\n\t\t_validateField: function(field, options, skipAjaxValidation) {\r\n\t\t\tif (!field.attr(\"id\")) {\r\n\t\t\t\tfield.attr(\"id\", \"form-validation-field-\" + $.validationEngine.fieldIdCounter);\r\n\t\t\t\t++$.validationEngine.fieldIdCounter;\r\n\t\t\t}\r\n\r\n           if (!options.validateNonVisibleFields && (field.is(\":hidden\") && !options.prettySelect || field.parent().is(\":hidden\")))\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tvar rulesParsing = field.attr(options.validateAttribute);\r\n\t\t\tvar getRules = /validate\\[(.*)\\]/.exec(rulesParsing);\r\n\r\n\t\t\tif (!getRules)\r\n\t\t\t\treturn false;\r\n\t\t\tvar str = getRules[1];\r\n\t\t\tvar rules = str.split(/\\[|,|\\]/);\r\n\r\n\t\t\t// true if we ran the ajax validation, tells the logic to stop messing with prompts\r\n\t\t\tvar isAjaxValidator = false;\r\n\t\t\tvar fieldName = field.attr(\"name\");\r\n\t\t\tvar promptText = \"\";\r\n\t\t\tvar promptType = \"\";\r\n\t\t\tvar required = false;\r\n\t\t\tvar limitErrors = false;\r\n\t\t\toptions.isError = false;\r\n\t\t\toptions.showArrow = true;\r\n\t\t\t\r\n\t\t\t// If the programmer wants to limit the amount of error messages per field,\r\n\t\t\tif (options.maxErrorsPerField > 0) {\r\n\t\t\t\tlimitErrors = true;\r\n\t\t\t}\r\n\r\n\t\t\tvar form = $(field.closest(\"form, .validationEngineContainer\"));\r\n\t\t\t// Fix for adding spaces in the rules\r\n\t\t\tfor (var i = 0; i < rules.length; i++) {\r\n\t\t\t\trules[i] = rules[i].replace(\" \", \"\");\r\n\t\t\t\t// Remove any parsing errors\r\n\t\t\t\tif (rules[i] === '') {\r\n\t\t\t\t\tdelete rules[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i = 0, field_errors = 0; i < rules.length; i++) {\r\n\t\t\t\t\r\n\t\t\t\t// If we are limiting errors, and have hit the max, break\r\n\t\t\t\tif (limitErrors && field_errors >= options.maxErrorsPerField) {\r\n\t\t\t\t\t// If we haven't hit a required yet, check to see if there is one in the validation rules for this\r\n\t\t\t\t\t// field and that it's index is greater or equal to our current index\r\n\t\t\t\t\tif (!required) {\r\n\t\t\t\t\t\tvar have_required = $.inArray('required', rules);\r\n\t\t\t\t\t\trequired = (have_required != -1 &&  have_required >= i);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tvar errorMsg = undefined;\r\n\t\t\t\tswitch (rules[i]) {\r\n\r\n\t\t\t\t\tcase \"required\":\r\n\t\t\t\t\t\trequired = true;\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._required);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"custom\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._custom);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"groupRequired\":\r\n\t\t\t\t\t\t// Check is its the first of group, if not, reload validation with first field\r\n\t\t\t\t\t\t// AND continue normal validation on present field\r\n\t\t\t\t\t\tvar classGroup = \"[\"+options.validateAttribute+\"*=\" +rules[i + 1] +\"]\";\r\n\t\t\t\t\t\tvar firstOfGroup = form.find(classGroup).eq(0);\r\n\t\t\t\t\t\tif(firstOfGroup[0] != field[0]){\r\n\r\n\t\t\t\t\t\t\tmethods._validateField(firstOfGroup, options, skipAjaxValidation); \r\n\t\t\t\t\t\t\toptions.showArrow = true;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._groupRequired);\r\n\t\t\t\t\t\tif(errorMsg)  required = true;\r\n\t\t\t\t\t\toptions.showArrow = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"ajax\":\r\n\t\t\t\t\t\t// AJAX defaults to returning it's loading message\r\n\t\t\t\t\t\terrorMsg = methods._ajax(field, rules, i, options);\r\n\t\t\t\t\t\tif (errorMsg) {\r\n\t\t\t\t\t\t\tpromptType = \"load\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"minSize\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._minSize);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"maxSize\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._maxSize);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"min\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._min);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"max\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._max);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"past\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field,rules[i], rules, i, options, methods._past);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"future\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field,rules[i], rules, i, options, methods._future);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"dateRange\":\r\n\t\t\t\t\t\tvar classGroup = \"[\"+options.validateAttribute+\"*=\" + rules[i + 1] + \"]\";\r\n\t\t\t\t\t\toptions.firstOfGroup = form.find(classGroup).eq(0);\r\n\t\t\t\t\t\toptions.secondOfGroup = form.find(classGroup).eq(1);\r\n\r\n\t\t\t\t\t\t//if one entry out of the pair has value then proceed to run through validation\r\n\t\t\t\t\t\tif (options.firstOfGroup[0].value || options.secondOfGroup[0].value) {\r\n\t\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field,rules[i], rules, i, options, methods._dateRange);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (errorMsg) required = true;\r\n\t\t\t\t\t\toptions.showArrow = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"dateTimeRange\":\r\n\t\t\t\t\t\tvar classGroup = \"[\"+options.validateAttribute+\"*=\" + rules[i + 1] + \"]\";\r\n\t\t\t\t\t\toptions.firstOfGroup = form.find(classGroup).eq(0);\r\n\t\t\t\t\t\toptions.secondOfGroup = form.find(classGroup).eq(1);\r\n\r\n\t\t\t\t\t\t//if one entry out of the pair has value then proceed to run through validation\r\n\t\t\t\t\t\tif (options.firstOfGroup[0].value || options.secondOfGroup[0].value) {\r\n\t\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field,rules[i], rules, i, options, methods._dateTimeRange);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (errorMsg) required = true;\r\n\t\t\t\t\t\toptions.showArrow = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"maxCheckbox\":\r\n\t\t\t\t\t\tfield = $(form.find(\"input[name='\" + fieldName + \"']\"));\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._maxCheckbox);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"minCheckbox\":\r\n\t\t\t\t\t\tfield = $(form.find(\"input[name='\" + fieldName + \"']\"));\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._minCheckbox);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"equals\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._equals);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"funcCall\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._funcCall);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"creditCard\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._creditCard);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"condRequired\":\r\n\t\t\t\t\t\terrorMsg = methods._getErrorMessage(form, field, rules[i], rules, i, options, methods._condRequired);\r\n\t\t\t\t\t\tif (errorMsg !== undefined) {\r\n\t\t\t\t\t\t\trequired = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar end_validation = false;\r\n\t\t\t\t\r\n\t\t\t\t// If we were passed back an message object, check what the status was to determine what to do\r\n\t\t\t\tif (typeof errorMsg == \"object\") {\r\n\t\t\t\t\tswitch (errorMsg.status) {\r\n\t\t\t\t\t\tcase \"_break\":\r\n\t\t\t\t\t\t\tend_validation = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t// If we have an error message, set errorMsg to the error message\r\n\t\t\t\t\t\tcase \"_error\":\r\n\t\t\t\t\t\t\terrorMsg = errorMsg.message;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t// If we want to throw an error, but not show a prompt, return early with true\r\n\t\t\t\t\t\tcase \"_error_no_prompt\":\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t// Anything else we continue on\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// If it has been specified that validation should end now, break\r\n\t\t\t\tif (end_validation) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// If we have a string, that means that we have an error, so add it to the error message.\r\n\t\t\t\tif (typeof errorMsg == 'string') {\r\n\t\t\t\t\tpromptText += errorMsg + \"<br/>\";\r\n\t\t\t\t\toptions.isError = true;\r\n\t\t\t\t\tfield_errors++;\r\n\t\t\t\t}\t\r\n\t\t\t}\r\n\t\t\t// If the rules required is not added, an empty field is not validated\r\n\t\t\tif(!required && !(field.val()) && field.val().length < 1) options.isError = false;\r\n\r\n\t\t\t// Hack for radio/checkbox group button, the validation go into the\r\n\t\t\t// first radio/checkbox of the group\r\n\t\t\tvar fieldType = field.prop(\"type\");\r\n\t\t\tvar positionType=field.data(\"promptPosition\") || options.promptPosition;\r\n\r\n\t\t\tif ((fieldType == \"radio\" || fieldType == \"checkbox\") && form.find(\"input[name='\" + fieldName + \"']\").size() > 1) {\r\n\t\t\t\tif(positionType === 'inline') {\r\n\t\t\t\t\tfield = $(form.find(\"input[name='\" + fieldName + \"'][type!=hidden]:last\"));\r\n\t\t\t\t} else {\r\n\t\t\t\tfield = $(form.find(\"input[name='\" + fieldName + \"'][type!=hidden]:first\"));\r\n\t\t\t\t}\r\n\t\t\t\toptions.showArrow = false;\r\n\t\t\t}\r\n\r\n\t\t\tif(field.is(\":hidden\") && options.prettySelect) {\r\n\t\t\t\tfield = form.find(\"#\" + options.usePrefix + methods._jqSelector(field.attr('id')) + options.useSuffix);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.isError && options.showPrompts){\r\n\t\t\t\tmethods._showPrompt(field, promptText, promptType, false, options);\r\n\t\t\t}else{\r\n\t\t\t\tif (!isAjaxValidator) methods._closePrompt(field);\r\n\t\t\t}\r\n\r\n\t\t\tif (!isAjaxValidator) {\r\n\t\t\t\tfield.trigger(\"jqv.field.result\", [field, options.isError, promptText]);\r\n\t\t\t}\r\n\r\n\t\t\t/* Record error */\r\n\t\t\tvar errindex = $.inArray(field[0], options.InvalidFields);\r\n\t\t\tif (errindex == -1) {\r\n\t\t\t\tif (options.isError)\r\n\t\t\t\toptions.InvalidFields.push(field[0]);\r\n\t\t\t} else if (!options.isError) {\r\n\t\t\t\toptions.InvalidFields.splice(errindex, 1);\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tmethods._handleStatusCssClasses(field, options);\r\n\t\r\n\t\t\t/* run callback function for each field */\r\n\t\t\tif (options.isError && options.onFieldFailure)\r\n\t\t\t\toptions.onFieldFailure(field);\r\n\r\n\t\t\tif (!options.isError && options.onFieldSuccess)\r\n\t\t\t\toptions.onFieldSuccess(field);\r\n\r\n\t\t\treturn options.isError;\r\n\t\t},\r\n\t\t/**\r\n\t\t* Handling css classes of fields indicating result of validation \r\n\t\t*\r\n\t\t* @param {jqObject}\r\n\t\t*            field\r\n\t\t* @param {Array[String]}\r\n\t\t*            field's validation rules            \r\n\t\t* @private\r\n\t\t*/\r\n\t\t_handleStatusCssClasses: function(field, options) {\r\n\t\t\t/* remove all classes */\r\n\t\t\tif(options.addSuccessCssClassToField)\r\n\t\t\t\tfield.removeClass(options.addSuccessCssClassToField);\r\n\t\t\t\r\n\t\t\tif(options.addFailureCssClassToField)\r\n\t\t\t\tfield.removeClass(options.addFailureCssClassToField);\r\n\t\t\t\r\n\t\t\t/* Add classes */\r\n\t\t\tif (options.addSuccessCssClassToField && !options.isError)\r\n\t\t\t\tfield.addClass(options.addSuccessCssClassToField);\r\n\t\t\t\r\n\t\t\tif (options.addFailureCssClassToField && options.isError)\r\n\t\t\t\tfield.addClass(options.addFailureCssClassToField);\t\t\r\n\t\t},\r\n\t\t\r\n\t\t /********************\r\n\t\t  * _getErrorMessage\r\n\t\t  *\r\n\t\t  * @param form\r\n\t\t  * @param field\r\n\t\t  * @param rule\r\n\t\t  * @param rules\r\n\t\t  * @param i\r\n\t\t  * @param options\r\n\t\t  * @param originalValidationMethod\r\n\t\t  * @return {*}\r\n\t\t  * @private\r\n\t\t  */\r\n\t\t _getErrorMessage:function (form, field, rule, rules, i, options, originalValidationMethod) {\r\n\t\t\t // If we are using the custon validation type, build the index for the rule.\r\n\t\t\t // Otherwise if we are doing a function call, make the call and return the object\r\n\t\t\t // that is passed back.\r\n\t \t\t var rule_index = jQuery.inArray(rule, rules);\r\n\t\t\t if (rule === \"custom\" || rule === \"funcCall\") {\r\n\t\t\t\t var custom_validation_type = rules[rule_index + 1];\r\n\t\t\t\t rule = rule + \"[\" + custom_validation_type + \"]\";\r\n\t\t\t\t // Delete the rule from the rules array so that it doesn't try to call the\r\n\t\t\t    // same rule over again\r\n\t\t\t    delete(rules[rule_index]);\r\n\t\t\t }\r\n\t\t\t // Change the rule to the composite rule, if it was different from the original\r\n\t\t\t var alteredRule = rule;\r\n\r\n\r\n\t\t\t var element_classes = (field.attr(\"data-validation-engine\")) ? field.attr(\"data-validation-engine\") : field.attr(\"class\");\r\n\t\t\t var element_classes_array = element_classes.split(\" \");\r\n\r\n\t\t\t // Call the original validation method. If we are dealing with dates or checkboxes, also pass the form\r\n\t\t\t var errorMsg;\r\n\t\t\t if (rule == \"future\" || rule == \"past\"  || rule == \"maxCheckbox\" || rule == \"minCheckbox\") {\r\n\t\t\t\t errorMsg = originalValidationMethod(form, field, rules, i, options);\r\n\t\t\t } else {\r\n\t\t\t\t errorMsg = originalValidationMethod(field, rules, i, options);\r\n\t\t\t }\r\n\r\n\t\t\t // If the original validation method returned an error and we have a custom error message,\r\n\t\t\t // return the custom message instead. Otherwise return the original error message.\r\n\t\t\t if (errorMsg != undefined) {\r\n\t\t\t\t var custom_message = methods._getCustomErrorMessage($(field), element_classes_array, alteredRule, options);\r\n\t\t\t\t if (custom_message) errorMsg = custom_message;\r\n\t\t\t }\r\n\t\t\t return errorMsg;\r\n\r\n\t\t },\r\n\t\t _getCustomErrorMessage:function (field, classes, rule, options) {\r\n\t\t\tvar custom_message = false;\r\n\t\t\tvar validityProp = /^custom\\[.*\\]$/.test(rule) ? methods._validityProp[\"custom\"] : methods._validityProp[rule];\r\n\t\t\t // If there is a validityProp for this rule, check to see if the field has an attribute for it\r\n\t\t\tif (validityProp != undefined) {\r\n\t\t\t\tcustom_message = field.attr(\"data-errormessage-\"+validityProp);\r\n\t\t\t\t// If there was an error message for it, return the message\r\n\t\t\t\tif (custom_message != undefined) \r\n\t\t\t\t\treturn custom_message;\r\n\t\t\t}\r\n\t\t\tcustom_message = field.attr(\"data-errormessage\");\r\n\t\t\t // If there is an inline custom error message, return it\r\n\t\t\tif (custom_message != undefined) \r\n\t\t\t\treturn custom_message;\r\n\t\t\tvar id = '#' + field.attr(\"id\");\r\n\t\t\t// If we have custom messages for the element's id, get the message for the rule from the id.\r\n\t\t\t// Otherwise, if we have custom messages for the element's classes, use the first class message we find instead.\r\n\t\t\tif (typeof options.custom_error_messages[id] != \"undefined\" &&\r\n\t\t\t\ttypeof options.custom_error_messages[id][rule] != \"undefined\" ) {\r\n\t\t\t\t\t\t  custom_message = options.custom_error_messages[id][rule]['message'];\r\n\t\t\t} else if (classes.length > 0) {\r\n\t\t\t\tfor (var i = 0; i < classes.length && classes.length > 0; i++) {\r\n\t\t\t\t\t var element_class = \".\" + classes[i];\r\n\t\t\t\t\tif (typeof options.custom_error_messages[element_class] != \"undefined\" &&\r\n\t\t\t\t\t\ttypeof options.custom_error_messages[element_class][rule] != \"undefined\") {\r\n\t\t\t\t\t\t\tcustom_message = options.custom_error_messages[element_class][rule]['message'];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!custom_message &&\r\n\t\t\t\ttypeof options.custom_error_messages[rule] != \"undefined\" &&\r\n\t\t\t\ttypeof options.custom_error_messages[rule]['message'] != \"undefined\"){\r\n\t\t\t\t\t custom_message = options.custom_error_messages[rule]['message'];\r\n\t\t\t }\r\n\t\t\t return custom_message;\r\n\t\t },\r\n\t\t _validityProp: {\r\n\t\t\t \"required\": \"value-missing\",\r\n\t\t\t \"custom\": \"custom-error\",\r\n\t\t\t \"groupRequired\": \"value-missing\",\r\n\t\t\t \"ajax\": \"custom-error\",\r\n\t\t\t \"minSize\": \"range-underflow\",\r\n\t\t\t \"maxSize\": \"range-overflow\",\r\n\t\t\t \"min\": \"range-underflow\",\r\n\t\t\t \"max\": \"range-overflow\",\r\n\t\t\t \"past\": \"type-mismatch\",\r\n\t\t\t \"future\": \"type-mismatch\",\r\n\t\t\t \"dateRange\": \"type-mismatch\",\r\n\t\t\t \"dateTimeRange\": \"type-mismatch\",\r\n\t\t\t \"maxCheckbox\": \"range-overflow\",\r\n\t\t\t \"minCheckbox\": \"range-underflow\",\r\n\t\t\t \"equals\": \"pattern-mismatch\",\r\n\t\t\t \"funcCall\": \"custom-error\",\r\n\t\t\t \"creditCard\": \"pattern-mismatch\",\r\n\t\t\t \"condRequired\": \"value-missing\"\r\n\t\t },\r\n\t\t/**\r\n\t\t* Required validation\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @param {bool} condRequired flag when method is used for internal purpose in condRequired check\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_required: function(field, rules, i, options, condRequired) {\r\n\t\t\tswitch (field.prop(\"type\")) {\r\n\t\t\t\tcase \"text\":\r\n\t\t\t\tcase \"password\":\r\n\t\t\t\tcase \"textarea\":\r\n\t\t\t\tcase \"file\":\r\n\t\t\t\tcase \"select-one\":\r\n\t\t\t\tcase \"select-multiple\":\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tvar field_val      = $.trim( field.val()                               );\r\n\t\t\t\t\tvar dv_placeholder = $.trim( field.attr(\"data-validation-placeholder\") );\r\n\t\t\t\t\tvar placeholder    = $.trim( field.attr(\"placeholder\")                 );\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\t   ( !field_val                                    )\r\n\t\t\t\t\t\t|| ( dv_placeholder && field_val == dv_placeholder )\r\n\t\t\t\t\t\t|| ( placeholder    && field_val == placeholder    )\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\treturn options.allrules[rules[i]].alertText;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"radio\":\r\n\t\t\t\tcase \"checkbox\":\r\n\t\t\t\t\t// new validation style to only check dependent field\r\n\t\t\t\t\tif (condRequired) {\r\n\t\t\t\t\t\tif (!field.attr('checked')) {\r\n\t\t\t\t\t\t\treturn options.allrules[rules[i]].alertTextCheckboxMultiple;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// old validation style\r\n\t\t\t\t\tvar form = field.closest(\"form, .validationEngineContainer\");\r\n\t\t\t\t\tvar name = field.attr(\"name\");\r\n\t\t\t\t\tif (form.find(\"input[name='\" + name + \"']:checked\").size() == 0) {\r\n\t\t\t\t\t\tif (form.find(\"input[name='\" + name + \"']:visible\").size() == 1)\r\n\t\t\t\t\t\t\treturn options.allrules[rules[i]].alertTextCheckboxe;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\treturn options.allrules[rules[i]].alertTextCheckboxMultiple;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Validate that 1 from the group field is required\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_groupRequired: function(field, rules, i, options) {\r\n\t\t\tvar classGroup = \"[\"+options.validateAttribute+\"*=\" +rules[i + 1] +\"]\";\r\n\t\t\tvar isValid = false;\r\n\t\t\t// Check all fields from the group\r\n\t\t\tfield.closest(\"form, .validationEngineContainer\").find(classGroup).each(function(){\r\n\t\t\t\tif(!methods._required($(this), rules, i, options)){\r\n\t\t\t\t\tisValid = true;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}); \r\n\r\n\t\t\tif(!isValid) {\r\n\t\t  return options.allrules[rules[i]].alertText;\r\n\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Validate rules\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_custom: function(field, rules, i, options) {\r\n\t\t\tvar customRule = rules[i + 1];\r\n\t\t\tvar rule = options.allrules[customRule];\r\n\t\t\tvar fn;\r\n\t\t\tif(!rule) {\r\n\t\t\t\talert(\"jqv:custom rule not found - \"+customRule);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(rule[\"regex\"]) {\r\n\t\t\t\t var ex=rule.regex;\r\n\t\t\t\t\tif(!ex) {\r\n\t\t\t\t\t\talert(\"jqv:custom regex not found - \"+customRule);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar pattern = new RegExp(ex);\r\n\r\n\t\t\t\t\tif (!pattern.test(field.val())) return options.allrules[customRule].alertText;\r\n\t\t\t\t\t\r\n\t\t\t} else if(rule[\"func\"]) {\r\n\t\t\t\tfn = rule[\"func\"]; \r\n\t\t\t\t \r\n\t\t\t\tif (typeof(fn) !== \"function\") {\r\n\t\t\t\t\talert(\"jqv:custom parameter 'function' is no function - \"+customRule);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t \r\n\t\t\t\tif (!fn(field, rules, i, options))\r\n\t\t\t\t\treturn options.allrules[customRule].alertText;\r\n\t\t\t} else {\r\n\t\t\t\talert(\"jqv:custom type not allowed \"+customRule);\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Validate custom function outside of the engine scope\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_funcCall: function(field, rules, i, options) {\r\n\t\t\tvar functionName = rules[i + 1];\r\n\t\t\tvar fn;\r\n\t\t\tif(functionName.indexOf('.') >-1)\r\n\t\t\t{\r\n\t\t\t\tvar namespaces = functionName.split('.');\r\n\t\t\t\tvar scope = window;\r\n\t\t\t\twhile(namespaces.length)\r\n\t\t\t\t{\r\n\t\t\t\t\tscope = scope[namespaces.shift()];\r\n\t\t\t\t}\r\n\t\t\t\tfn = scope;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tfn = window[functionName] || options.customFunctions[functionName];\r\n\t\t\tif (typeof(fn) == 'function')\r\n\t\t\t\treturn fn(field, rules, i, options);\r\n\r\n\t\t},\r\n\t\t/**\r\n\t\t* Field match\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_equals: function(field, rules, i, options) {\r\n\t\t\tvar equalsField = rules[i + 1];\r\n\r\n\t\t\tif (field.val() != $(\"#\" + equalsField).val())\r\n\t\t\t\treturn options.allrules.equals.alertText;\r\n\t\t},\r\n\t\t/**\r\n\t\t* Check the maximum size (in characters)\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_maxSize: function(field, rules, i, options) {\r\n\t\t\tvar max = rules[i + 1];\r\n\t\t\tvar len = field.val().length;\r\n\r\n\t\t\tif (len > max) {\r\n\t\t\t\tvar rule = options.allrules.maxSize;\r\n\t\t\t\treturn rule.alertText + max + rule.alertText2;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Check the minimum size (in characters)\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_minSize: function(field, rules, i, options) {\r\n\t\t\tvar min = rules[i + 1];\r\n\t\t\tvar len = field.val().length;\r\n\r\n\t\t\tif (len < min) {\r\n\t\t\t\tvar rule = options.allrules.minSize;\r\n\t\t\t\treturn rule.alertText + min + rule.alertText2;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Check number minimum value\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_min: function(field, rules, i, options) {\r\n\t\t\tvar min = parseFloat(rules[i + 1]);\r\n\t\t\tvar len = parseFloat(field.val());\r\n\r\n\t\t\tif (len < min) {\r\n\t\t\t\tvar rule = options.allrules.min;\r\n\t\t\t\tif (rule.alertText2) return rule.alertText + min + rule.alertText2;\r\n\t\t\t\treturn rule.alertText + min;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Check number maximum value\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_max: function(field, rules, i, options) {\r\n\t\t\tvar max = parseFloat(rules[i + 1]);\r\n\t\t\tvar len = parseFloat(field.val());\r\n\r\n\t\t\tif (len >max ) {\r\n\t\t\t\tvar rule = options.allrules.max;\r\n\t\t\t\tif (rule.alertText2) return rule.alertText + max + rule.alertText2;\r\n\t\t\t\t//orefalo: to review, also do the translations\r\n\t\t\t\treturn rule.alertText + max;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Checks date is in the past\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_past: function(form, field, rules, i, options) {\r\n\r\n\t\t\tvar p=rules[i + 1];\r\n\t\t\tvar fieldAlt = $(form.find(\"input[name='\" + p.replace(/^#+/, '') + \"']\"));\r\n\t\t\tvar pdate;\r\n\r\n\t\t\tif (p.toLowerCase() == \"now\") {\r\n\t\t\t\tpdate = new Date();\r\n\t\t\t} else if (undefined != fieldAlt.val()) {\r\n\t\t\t\tif (fieldAlt.is(\":disabled\"))\r\n\t\t\t\t\treturn;\r\n\t\t\t\tpdate = methods._parseDate(fieldAlt.val());\r\n\t\t\t} else {\r\n\t\t\t\tpdate = methods._parseDate(p);\r\n\t\t\t}\r\n\t\t\tvar vdate = methods._parseDate(field.val());\r\n\r\n\t\t\tif (vdate > pdate ) {\r\n\t\t\t\tvar rule = options.allrules.past;\r\n\t\t\t\tif (rule.alertText2) return rule.alertText + methods._dateToString(pdate) + rule.alertText2;\r\n\t\t\t\treturn rule.alertText + methods._dateToString(pdate);\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Checks date is in the future\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_future: function(form, field, rules, i, options) {\r\n\r\n\t\t\tvar p=rules[i + 1];\r\n\t\t\tvar fieldAlt = $(form.find(\"input[name='\" + p.replace(/^#+/, '') + \"']\"));\r\n\t\t\tvar pdate;\r\n\r\n\t\t\tif (p.toLowerCase() == \"now\") {\r\n\t\t\t\tpdate = new Date();\r\n\t\t\t} else if (undefined != fieldAlt.val()) {\r\n\t\t\t\tif (fieldAlt.is(\":disabled\"))\r\n\t\t\t\t\treturn;\r\n\t\t\t\tpdate = methods._parseDate(fieldAlt.val());\r\n\t\t\t} else {\r\n\t\t\t\tpdate = methods._parseDate(p);\r\n\t\t\t}\r\n\t\t\tvar vdate = methods._parseDate(field.val());\r\n\r\n\t\t\tif (vdate < pdate ) {\r\n\t\t\t\tvar rule = options.allrules.future;\r\n\t\t\t\tif (rule.alertText2)\r\n\t\t\t\t\treturn rule.alertText + methods._dateToString(pdate) + rule.alertText2;\r\n\t\t\t\treturn rule.alertText + methods._dateToString(pdate);\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Checks if valid date\r\n\t\t*\r\n\t\t* @param {string} date string\r\n\t\t* @return a bool based on determination of valid date\r\n\t\t*/\r\n\t\t_isDate: function (value) {\r\n\t\t\tvar dateRegEx = new RegExp(/^\\d{4}[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])$|^(?:(?:(?:0?[13578]|1[02])(\\/|-)31)|(?:(?:0?[1,3-9]|1[0-2])(\\/|-)(?:29|30)))(\\/|-)(?:[1-9]\\d\\d\\d|\\d[1-9]\\d\\d|\\d\\d[1-9]\\d|\\d\\d\\d[1-9])$|^(?:(?:0?[1-9]|1[0-2])(\\/|-)(?:0?[1-9]|1\\d|2[0-8]))(\\/|-)(?:[1-9]\\d\\d\\d|\\d[1-9]\\d\\d|\\d\\d[1-9]\\d|\\d\\d\\d[1-9])$|^(0?2(\\/|-)29)(\\/|-)(?:(?:0[48]00|[13579][26]00|[2468][048]00)|(?:\\d\\d)?(?:0[48]|[2468][048]|[13579][26]))$/);\r\n\t\t\treturn dateRegEx.test(value);\r\n\t\t},\r\n\t\t/**\r\n\t\t* Checks if valid date time\r\n\t\t*\r\n\t\t* @param {string} date string\r\n\t\t* @return a bool based on determination of valid date time\r\n\t\t*/\r\n\t\t_isDateTime: function (value){\r\n\t\t\tvar dateTimeRegEx = new RegExp(/^\\d{4}[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])\\s+(1[012]|0?[1-9]){1}:(0?[1-5]|[0-6][0-9]){1}:(0?[0-6]|[0-6][0-9]){1}\\s+(am|pm|AM|PM){1}$|^(?:(?:(?:0?[13578]|1[02])(\\/|-)31)|(?:(?:0?[1,3-9]|1[0-2])(\\/|-)(?:29|30)))(\\/|-)(?:[1-9]\\d\\d\\d|\\d[1-9]\\d\\d|\\d\\d[1-9]\\d|\\d\\d\\d[1-9])$|^((1[012]|0?[1-9]){1}\\/(0?[1-9]|[12][0-9]|3[01]){1}\\/\\d{2,4}\\s+(1[012]|0?[1-9]){1}:(0?[1-5]|[0-6][0-9]){1}:(0?[0-6]|[0-6][0-9]){1}\\s+(am|pm|AM|PM){1})$/);\r\n\t\t\treturn dateTimeRegEx.test(value);\r\n\t\t},\r\n\t\t//Checks if the start date is before the end date\r\n\t\t//returns true if end is later than start\r\n\t\t_dateCompare: function (start, end) {\r\n\t\t\treturn (new Date(start.toString()) < new Date(end.toString()));\r\n\t\t},\r\n\t\t/**\r\n\t\t* Checks date range\r\n\t\t*\r\n\t\t* @param {jqObject} first field name\r\n\t\t* @param {jqObject} second field name\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_dateRange: function (field, rules, i, options) {\r\n\t\t\t//are not both populated\r\n\t\t\tif ((!options.firstOfGroup[0].value && options.secondOfGroup[0].value) || (options.firstOfGroup[0].value && !options.secondOfGroup[0].value)) {\r\n\t\t\t\treturn options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;\r\n\t\t\t}\r\n\r\n\t\t\t//are not both dates\r\n\t\t\tif (!methods._isDate(options.firstOfGroup[0].value) || !methods._isDate(options.secondOfGroup[0].value)) {\r\n\t\t\t\treturn options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;\r\n\t\t\t}\r\n\r\n\t\t\t//are both dates but range is off\r\n\t\t\tif (!methods._dateCompare(options.firstOfGroup[0].value, options.secondOfGroup[0].value)) {\r\n\t\t\t\treturn options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Checks date time range\r\n\t\t*\r\n\t\t* @param {jqObject} first field name\r\n\t\t* @param {jqObject} second field name\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_dateTimeRange: function (field, rules, i, options) {\r\n\t\t\t//are not both populated\r\n\t\t\tif ((!options.firstOfGroup[0].value && options.secondOfGroup[0].value) || (options.firstOfGroup[0].value && !options.secondOfGroup[0].value)) {\r\n\t\t\t\treturn options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;\r\n\t\t\t}\r\n\t\t\t//are not both dates\r\n\t\t\tif (!methods._isDateTime(options.firstOfGroup[0].value) || !methods._isDateTime(options.secondOfGroup[0].value)) {\r\n\t\t\t\treturn options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;\r\n\t\t\t}\r\n\t\t\t//are both dates but range is off\r\n\t\t\tif (!methods._dateCompare(options.firstOfGroup[0].value, options.secondOfGroup[0].value)) {\r\n\t\t\t\treturn options.allrules[rules[i]].alertText + options.allrules[rules[i]].alertText2;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Max number of checkbox selected\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_maxCheckbox: function(form, field, rules, i, options) {\r\n\r\n\t\t\tvar nbCheck = rules[i + 1];\r\n\t\t\tvar groupname = field.attr(\"name\");\r\n\t\t\tvar groupSize = form.find(\"input[name='\" + groupname + \"']:checked\").size();\r\n\t\t\tif (groupSize > nbCheck) {\r\n\t\t\t\toptions.showArrow = false;\r\n\t\t\t\tif (options.allrules.maxCheckbox.alertText2)\r\n\t\t\t\t\t return options.allrules.maxCheckbox.alertText + \" \" + nbCheck + \" \" + options.allrules.maxCheckbox.alertText2;\r\n\t\t\t\treturn options.allrules.maxCheckbox.alertText;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Min number of checkbox selected\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_minCheckbox: function(form, field, rules, i, options) {\r\n\r\n\t\t\tvar nbCheck = rules[i + 1];\r\n\t\t\tvar groupname = field.attr(\"name\");\r\n\t\t\tvar groupSize = form.find(\"input[name='\" + groupname + \"']:checked\").size();\r\n\t\t\tif (groupSize < nbCheck) {\r\n\t\t\t\toptions.showArrow = false;\r\n\t\t\t\treturn options.allrules.minCheckbox.alertText + \" \" + nbCheck + \" \" + options.allrules.minCheckbox.alertText2;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Checks that it is a valid credit card number according to the\r\n\t\t* Luhn checksum algorithm.\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_creditCard: function(field, rules, i, options) {\r\n\t\t\t//spaces and dashes may be valid characters, but must be stripped to calculate the checksum.\r\n\t\t\tvar valid = false, cardNumber = field.val().replace(/ +/g, '').replace(/-+/g, '');\r\n\r\n\t\t\tvar numDigits = cardNumber.length;\r\n\t\t\tif (numDigits >= 14 && numDigits <= 16 && parseInt(cardNumber) > 0) {\r\n\r\n\t\t\t\tvar sum = 0, i = numDigits - 1, pos = 1, digit, luhn = new String();\r\n\t\t\t\tdo {\r\n\t\t\t\t\tdigit = parseInt(cardNumber.charAt(i));\r\n\t\t\t\t\tluhn += (pos++ % 2 == 0) ? digit * 2 : digit;\r\n\t\t\t\t} while (--i >= 0)\r\n\r\n\t\t\t\tfor (i = 0; i < luhn.length; i++) {\r\n\t\t\t\t\tsum += parseInt(luhn.charAt(i));\r\n\t\t\t\t}\r\n\t\t\t\tvalid = sum % 10 == 0;\r\n\t\t\t}\r\n\t\t\tif (!valid) return options.allrules.creditCard.alertText;\r\n\t\t},\r\n\t\t/**\r\n\t\t* Ajax field validation\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t*            user options\r\n\t\t* @return nothing! the ajax validator handles the prompts itself\r\n\t\t*/\r\n\t\t _ajax: function(field, rules, i, options) {\r\n\r\n\t\t\t var errorSelector = rules[i + 1];\r\n\t\t\t var rule = options.allrules[errorSelector];\r\n\t\t\t var extraData = rule.extraData;\r\n\t\t\t var extraDataDynamic = rule.extraDataDynamic;\r\n\t\t\t var data = {\r\n\t\t\t\t\"fieldId\" : field.attr(\"id\"),\r\n\t\t\t\t\"fieldValue\" : field.val()\r\n\t\t\t };\r\n\r\n\t\t\t if (typeof extraData === \"object\") {\r\n\t\t\t\t$.extend(data, extraData);\r\n\t\t\t } else if (typeof extraData === \"string\") {\r\n\t\t\t\tvar tempData = extraData.split(\"&\");\r\n\t\t\t\tfor(var i = 0; i < tempData.length; i++) {\r\n\t\t\t\t\tvar values = tempData[i].split(\"=\");\r\n\t\t\t\t\tif (values[0] && values[0]) {\r\n\t\t\t\t\t\tdata[values[0]] = values[1];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t }\r\n\r\n\t\t\t if (extraDataDynamic) {\r\n\t\t\t\t var tmpData = [];\r\n\t\t\t\t var domIds = String(extraDataDynamic).split(\",\");\r\n\t\t\t\t for (var i = 0; i < domIds.length; i++) {\r\n\t\t\t\t\t var id = domIds[i];\r\n\t\t\t\t\t if ($(id).length) {\r\n\t\t\t\t\t\t var inputValue = field.closest(\"form, .validationEngineContainer\").find(id).val();\r\n\t\t\t\t\t\t var keyValue = id.replace('#', '') + '=' + escape(inputValue);\r\n\t\t\t\t\t\t data[id.replace('#', '')] = inputValue;\r\n\t\t\t\t\t }\r\n\t\t\t\t }\r\n\t\t\t }\r\n\t\t\t \r\n\t\t\t // If a field change event triggered this we want to clear the cache for this ID\r\n\t\t\t if (options.eventTrigger == \"field\") {\r\n\t\t\t\tdelete(options.ajaxValidCache[field.attr(\"id\")]);\r\n\t\t\t }\r\n\r\n\t\t\t // If there is an error or if the the field is already validated, do not re-execute AJAX\r\n\t\t\t if (!options.isError && !methods._checkAjaxFieldStatus(field.attr(\"id\"), options)) {\r\n\t\t\t\t $.ajax({\r\n\t\t\t\t\t type: options.ajaxFormValidationMethod,\r\n\t\t\t\t\t url: rule.url,\r\n\t\t\t\t\t cache: false,\r\n\t\t\t\t\t dataType: \"json\",\r\n\t\t\t\t\t data: data,\r\n\t\t\t\t\t field: field,\r\n\t\t\t\t\t rule: rule,\r\n\t\t\t\t\t methods: methods,\r\n\t\t\t\t\t options: options,\r\n\t\t\t\t\t beforeSend: function() {},\r\n\t\t\t\t\t error: function(data, transport) {\r\n\t\t\t\t\t\t methods._ajaxError(data, transport);\r\n\t\t\t\t\t },\r\n\t\t\t\t\t success: function(json) {\r\n\r\n\t\t\t\t\t\t // asynchronously called on success, data is the json answer from the server\r\n\t\t\t\t\t\t var errorFieldId = json[0];\r\n\t\t\t\t\t\t //var errorField = $($(\"#\" + errorFieldId)[0]);\r\n\t\t\t\t\t\t var errorField = $(\"#\"+ errorFieldId).eq(0);\r\n\r\n\t\t\t\t\t\t // make sure we found the element\r\n\t\t\t\t\t\t if (errorField.length == 1) {\r\n\t\t\t\t\t\t\t var status = json[1];\r\n\t\t\t\t\t\t\t // read the optional msg from the server\r\n\t\t\t\t\t\t\t var msg = json[2];\r\n\t\t\t\t\t\t\t if (!status) {\r\n\t\t\t\t\t\t\t\t // Houston we got a problem - display an red prompt\r\n\t\t\t\t\t\t\t\t options.ajaxValidCache[errorFieldId] = false;\r\n\t\t\t\t\t\t\t\t options.isError = true;\r\n\r\n\t\t\t\t\t\t\t\t // resolve the msg prompt\r\n\t\t\t\t\t\t\t\t if(msg) {\r\n\t\t\t\t\t\t\t\t\t if (options.allrules[msg]) {\r\n\t\t\t\t\t\t\t\t\t\t var txt = options.allrules[msg].alertText;\r\n\t\t\t\t\t\t\t\t\t\t if (txt) {\r\n\t\t\t\t\t\t\t\t\t\t\tmsg = txt;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t else\r\n\t\t\t\t\t\t\t\t\tmsg = rule.alertText;\r\n\r\n\t\t\t\t\t\t\t\t if (options.showPrompts) methods._showPrompt(errorField, msg, \"\", true, options);\r\n\t\t\t\t\t\t\t } else {\r\n\t\t\t\t\t\t\t\t options.ajaxValidCache[errorFieldId] = true;\r\n\r\n\t\t\t\t\t\t\t\t // resolves the msg prompt\r\n\t\t\t\t\t\t\t\t if(msg) {\r\n\t\t\t\t\t\t\t\t\t if (options.allrules[msg]) {\r\n\t\t\t\t\t\t\t\t\t\t var txt = options.allrules[msg].alertTextOk;\r\n\t\t\t\t\t\t\t\t\t\t if (txt) {\r\n\t\t\t\t\t\t\t\t\t\t\tmsg = txt;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t else\r\n\t\t\t\t\t\t\t\t msg = rule.alertTextOk;\r\n\r\n\t\t\t\t\t\t\t\t if (options.showPrompts) {\r\n\t\t\t\t\t\t\t\t\t // see if we should display a green prompt\r\n\t\t\t\t\t\t\t\t\t if (msg)\r\n\t\t\t\t\t\t\t\t\t\tmethods._showPrompt(errorField, msg, \"pass\", true, options);\r\n\t\t\t\t\t\t\t\t\t else\r\n\t\t\t\t\t\t\t\t\t\tmethods._closePrompt(errorField);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t // If a submit form triggered this, we want to re-submit the form\r\n\t\t\t\t\t\t\t\t if (options.eventTrigger == \"submit\")\r\n\t\t\t\t\t\t\t\t\tfield.closest(\"form\").submit();\r\n\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\t errorField.trigger(\"jqv.field.result\", [errorField, options.isError, msg]);\r\n\t\t\t\t\t }\r\n\t\t\t\t });\r\n\t\t\t\t \r\n\t\t\t\t return rule.alertTextLoad;\r\n\t\t\t }\r\n\t\t },\r\n\t\t/**\r\n\t\t* Common method to handle ajax errors\r\n\t\t*\r\n\t\t* @param {Object} data\r\n\t\t* @param {Object} transport\r\n\t\t*/\r\n\t\t_ajaxError: function(data, transport) {\r\n\t\t\tif(data.status == 0 && transport == null)\r\n\t\t\t\talert(\"The page is not served from a server! ajax call failed\");\r\n\t\t\telse if(typeof console != \"undefined\")\r\n\t\t\t\tconsole.log(\"Ajax error: \" + data.status + \" \" + transport);\r\n\t\t},\r\n\t\t/**\r\n\t\t* date -> string\r\n\t\t*\r\n\t\t* @param {Object} date\r\n\t\t*/\r\n\t\t_dateToString: function(date) {\r\n\t\t\treturn date.getFullYear()+\"-\"+(date.getMonth()+1)+\"-\"+date.getDate();\r\n\t\t},\r\n\t\t/**\r\n\t\t* Parses an ISO date\r\n\t\t* @param {String} d\r\n\t\t*/\r\n\t\t_parseDate: function(d) {\r\n\r\n\t\t\tvar dateParts = d.split(\"-\");\r\n\t\t\tif(dateParts==d)\r\n\t\t\t\tdateParts = d.split(\"/\");\r\n\t\t\tif(dateParts==d) {\r\n\t\t\t\tdateParts = d.split(\".\");\r\n\t\t\t\treturn new Date(dateParts[2], (dateParts[1] - 1), dateParts[0]);\r\n\t\t\t}\r\n\t\t\treturn new Date(dateParts[0], (dateParts[1] - 1) ,dateParts[2]);\r\n\t\t},\r\n\t\t/**\r\n\t\t* Builds or updates a prompt with the given information\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {String} promptText html text to display type\r\n\t\t* @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)\r\n\t\t* @param {boolean} ajaxed - use to mark fields than being validated with ajax\r\n\t\t* @param {Map} options user options\r\n\t\t*/\r\n\t\t _showPrompt: function(field, promptText, type, ajaxed, options, ajaxform) {\r\n\t\t\t var prompt = methods._getPrompt(field);\r\n\t\t\t // The ajax submit errors are not see has an error in the form,\r\n\t\t\t // When the form errors are returned, the engine see 2 bubbles, but those are ebing closed by the engine at the same time\r\n\t\t\t // Because no error was found befor submitting\r\n\t\t\t if(ajaxform) prompt = false;\r\n\t\t\t // Check that there is indded text\r\n\t\t\t if($.trim(promptText)){ \r\n\t\t\t\t if (prompt)\r\n\t\t\t\t\tmethods._updatePrompt(field, prompt, promptText, type, ajaxed, options);\r\n\t\t\t\t else\r\n\t\t\t\t\tmethods._buildPrompt(field, promptText, type, ajaxed, options);\r\n\t\t\t}\r\n\t\t },\r\n\t\t/**\r\n\t\t* Builds and shades a prompt for the given field.\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {String} promptText html text to display type\r\n\t\t* @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)\r\n\t\t* @param {boolean} ajaxed - use to mark fields than being validated with ajax\r\n\t\t* @param {Map} options user options\r\n\t\t*/\r\n\t\t_buildPrompt: function(field, promptText, type, ajaxed, options) {\r\n\r\n\t\t\t// create the prompt\r\n\t\t\tvar prompt = $('<div>');\r\n\t\t\tprompt.addClass(methods._getClassName(field.attr(\"id\")) + \"formError\");\r\n\t\t\t// add a class name to identify the parent form of the prompt\r\n\t\t\tprompt.addClass(\"parentForm\"+methods._getClassName(field.closest('form, .validationEngineContainer').attr(\"id\")));\r\n\t\t\tprompt.addClass(\"formError\");\r\n\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase \"pass\":\r\n\t\t\t\t\tprompt.addClass(\"greenPopup\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"load\":\r\n\t\t\t\t\tprompt.addClass(\"blackPopup\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t/* it has error  */\r\n\t\t\t\t\t//alert(\"unknown popup type:\"+type);\r\n\t\t\t}\r\n\t\t\tif (ajaxed)\r\n\t\t\t\tprompt.addClass(\"ajaxed\");\r\n\r\n\t\t\t// create the prompt content\r\n\t\t\tvar promptContent = $('<div>').addClass(\"formErrorContent\").html(promptText).appendTo(prompt);\r\n\r\n\t\t\t// determine position type\r\n\t\t\tvar positionType=field.data(\"promptPosition\") || options.promptPosition;\r\n\r\n\t\t\t// create the css arrow pointing at the field\r\n\t\t\t// note that there is no triangle on max-checkbox and radio\r\n\t\t\tif (options.showArrow) {\r\n\t\t\t\tvar arrow = $('<div>').addClass(\"formErrorArrow\");\r\n\r\n\t\t\t\t//prompt positioning adjustment support. Usage: positionType:Xshift,Yshift (for ex.: bottomLeft:+20 or bottomLeft:-20,+10)\r\n\t\t\t\tif (typeof(positionType)=='string') \r\n\t\t\t\t{\r\n\t\t\t\t\tvar pos=positionType.indexOf(\":\");\r\n\t\t\t\t\tif(pos!=-1)\r\n\t\t\t\t\t\tpositionType=positionType.substring(0,pos);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tswitch (positionType) {\r\n\t\t\t\t\tcase \"bottomLeft\":\r\n\t\t\t\t\tcase \"bottomRight\":\r\n\t\t\t\t\t\tprompt.find(\".formErrorContent\").before(arrow);\r\n\t\t\t\t\t\tarrow.addClass(\"formErrorArrowBottom\").html('<div class=\"line1\"><!-- --></div><div class=\"line2\"><!-- --></div><div class=\"line3\"><!-- --></div><div class=\"line4\"><!-- --></div><div class=\"line5\"><!-- --></div><div class=\"line6\"><!-- --></div><div class=\"line7\"><!-- --></div><div class=\"line8\"><!-- --></div><div class=\"line9\"><!-- --></div><div class=\"line10\"><!-- --></div>');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"topLeft\":\r\n\t\t\t\t\tcase \"topRight\":\r\n\t\t\t\t\t\tarrow.html('<div class=\"line10\"><!-- --></div><div class=\"line9\"><!-- --></div><div class=\"line8\"><!-- --></div><div class=\"line7\"><!-- --></div><div class=\"line6\"><!-- --></div><div class=\"line5\"><!-- --></div><div class=\"line4\"><!-- --></div><div class=\"line3\"><!-- --></div><div class=\"line2\"><!-- --></div><div class=\"line1\"><!-- --></div>');\r\n\t\t\t\t\t\tprompt.append(arrow);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Add custom prompt class\r\n\t\t\tif (options.addPromptClass)\r\n\t\t\t\tprompt.addClass(options.addPromptClass);\r\n\r\n            // Add custom prompt class defined in element\r\n            var requiredOverride = field.attr('data-required-class');\r\n            if(requiredOverride !== undefined) {\r\n                prompt.addClass(requiredOverride);\r\n            } else {\r\n                if(options.prettySelect) {\r\n                    if($('#' + field.attr('id')).next().is('select')) {\r\n                        var prettyOverrideClass = $('#' + field.attr('id').substr(options.usePrefix.length).substring(options.useSuffix.length)).attr('data-required-class');\r\n                        if(prettyOverrideClass !== undefined) {\r\n                            prompt.addClass(prettyOverrideClass);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n\t\t\tprompt.css({\r\n\t\t\t\t\"opacity\": 0\r\n\t\t\t});\r\n\t\t\tif(positionType === 'inline') {\r\n\t\t\t\tprompt.addClass(\"inline\");\r\n\t\t\t\tif(typeof field.attr('data-prompt-target') !== 'undefined' && $('#'+field.attr('data-prompt-target')).length > 0) {\r\n\t\t\t\t\tprompt.appendTo($('#'+field.attr('data-prompt-target')));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfield.after(prompt);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfield.before(prompt);\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar pos = methods._calculatePosition(field, prompt, options);\r\n\t\t\tprompt.css({\r\n\t\t\t\t'position': positionType === 'inline' ? 'relative' : 'absolute',\r\n\t\t\t\t\"top\": pos.callerTopPosition,\r\n\t\t\t\t\"left\": pos.callerleftPosition,\r\n\t\t\t\t\"marginTop\": pos.marginTopSize,\r\n\t\t\t\t\"opacity\": 0\r\n\t\t\t}).data(\"callerField\", field);\r\n\t\t\t\r\n\r\n\t\t\tif (options.autoHidePrompt) {\r\n\t\t\t\tsetTimeout(function(){\r\n\t\t\t\t\tprompt.animate({\r\n\t\t\t\t\t\t\"opacity\": 0\r\n\t\t\t\t\t},function(){\r\n\t\t\t\t\t\tprompt.closest('.formErrorOuter').remove();\r\n\t\t\t\t\t\tprompt.remove();\r\n\t\t\t\t\t});\r\n\t\t\t\t}, options.autoHideDelay);\r\n\t\t\t} \r\n\t\t\treturn prompt.animate({\r\n\t\t\t\t\"opacity\": 0.87\r\n\t\t\t});\r\n\t\t},\r\n\t\t/**\r\n\t\t* Updates the prompt text field - the field for which the prompt\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {String} promptText html text to display type\r\n\t\t* @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)\r\n\t\t* @param {boolean} ajaxed - use to mark fields than being validated with ajax\r\n\t\t* @param {Map} options user options\r\n\t\t*/\r\n\t\t_updatePrompt: function(field, prompt, promptText, type, ajaxed, options, noAnimation) {\r\n\r\n\t\t\tif (prompt) {\r\n\t\t\t\tif (typeof type !== \"undefined\") {\r\n\t\t\t\t\tif (type == \"pass\")\r\n\t\t\t\t\t\tprompt.addClass(\"greenPopup\");\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tprompt.removeClass(\"greenPopup\");\r\n\r\n\t\t\t\t\tif (type == \"load\")\r\n\t\t\t\t\t\tprompt.addClass(\"blackPopup\");\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tprompt.removeClass(\"blackPopup\");\r\n\t\t\t\t}\r\n\t\t\t\tif (ajaxed)\r\n\t\t\t\t\tprompt.addClass(\"ajaxed\");\r\n\t\t\t\telse\r\n\t\t\t\t\tprompt.removeClass(\"ajaxed\");\r\n\r\n\t\t\t\tprompt.find(\".formErrorContent\").html(promptText);\r\n\r\n\t\t\t\tvar pos = methods._calculatePosition(field, prompt, options);\r\n\t\t\t\tvar css = {\"top\": pos.callerTopPosition,\r\n\t\t\t\t\"left\": pos.callerleftPosition,\r\n\t\t\t\t\"marginTop\": pos.marginTopSize};\r\n\r\n\t\t\t\tif (noAnimation)\r\n\t\t\t\t\tprompt.css(css);\r\n\t\t\t\telse\r\n\t\t\t\t\tprompt.animate(css);\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t* Closes the prompt associated with the given field\r\n\t\t*\r\n\t\t* @param {jqObject}\r\n\t\t*            field\r\n\t\t*/\r\n\t\t _closePrompt: function(field) {\r\n\t\t\t var prompt = methods._getPrompt(field);\r\n\t\t\t if (prompt)\r\n\t\t\t\t prompt.fadeTo(\"fast\", 0, function() {\r\n\t\t\t\t\t prompt.parent('.formErrorOuter').remove();\r\n\t\t\t\t\t prompt.remove();\r\n\t\t\t\t });\r\n\t\t },\r\n\t\t closePrompt: function(field) {\r\n\t\t\t return methods._closePrompt(field);\r\n\t\t },\r\n\t\t/**\r\n\t\t* Returns the error prompt matching the field if any\r\n\t\t*\r\n\t\t* @param {jqObject}\r\n\t\t*            field\r\n\t\t* @return undefined or the error prompt (jqObject)\r\n\t\t*/\r\n\t\t_getPrompt: function(field) {\r\n\t\t\t\tvar formId = $(field).closest('form, .validationEngineContainer').attr('id');\r\n\t\t\tvar className = methods._getClassName(field.attr(\"id\")) + \"formError\";\r\n\t\t\t\tvar match = $(\".\" + methods._escapeExpression(className) + '.parentForm' + formId)[0];\r\n\t\t\tif (match)\r\n\t\t\treturn $(match);\r\n\t\t},\r\n\t\t/**\r\n\t\t  * Returns the escapade classname\r\n\t\t  *\r\n\t\t  * @param {selector}\r\n\t\t  *            className\r\n\t\t  */\r\n\t\t  _escapeExpression: function (selector) {\r\n\t\t\t  return selector.replace(/([#;&,\\.\\+\\*\\~':\"\\!\\^$\\[\\]\\(\\)=>\\|])/g, \"\\\\$1\");\r\n\t\t  },\r\n\t\t/**\r\n\t\t * returns true if we are in a RTLed document\r\n\t\t *\r\n\t\t * @param {jqObject} field\r\n\t\t */\r\n\t\tisRTL: function(field)\r\n\t\t{\r\n\t\t\tvar $document = $(document);\r\n\t\t\tvar $body = $('body');\r\n\t\t\tvar rtl =\r\n\t\t\t\t(field && field.hasClass('rtl')) ||\r\n\t\t\t\t(field && (field.attr('dir') || '').toLowerCase()==='rtl') ||\r\n\t\t\t\t$document.hasClass('rtl') ||\r\n\t\t\t\t($document.attr('dir') || '').toLowerCase()==='rtl' ||\r\n\t\t\t\t$body.hasClass('rtl') ||\r\n\t\t\t\t($body.attr('dir') || '').toLowerCase()==='rtl';\r\n\t\t\treturn Boolean(rtl);\r\n\t\t},\r\n\t\t/**\r\n\t\t* Calculates prompt position\r\n\t\t*\r\n\t\t* @param {jqObject}\r\n\t\t*            field\r\n\t\t* @param {jqObject}\r\n\t\t*            the prompt\r\n\t\t* @param {Map}\r\n\t\t*            options\r\n\t\t* @return positions\r\n\t\t*/\r\n\t\t_calculatePosition: function (field, promptElmt, options) {\r\n\r\n\t\t\tvar promptTopPosition, promptleftPosition, marginTopSize;\r\n\t\t\tvar fieldWidth \t= field.width();\r\n\t\t\tvar fieldLeft \t= field.position().left; \r\n\t\t\tvar fieldTop \t=  field.position().top;\r\n\t\t\tvar fieldHeight \t=  field.height();\t\r\n\t\t\tvar promptHeight = promptElmt.height();\r\n\r\n\r\n\t\t\t// is the form contained in an overflown container?\r\n\t\t\tpromptTopPosition = promptleftPosition = 0;\r\n\t\t\t// compensation for the arrow\r\n\t\t\tmarginTopSize = -promptHeight;\r\n\t\t\r\n\r\n\t\t\t//prompt positioning adjustment support\r\n\t\t\t//now you can adjust prompt position\r\n\t\t\t//usage: positionType:Xshift,Yshift\r\n\t\t\t//for example:\r\n\t\t\t//   bottomLeft:+20 means bottomLeft position shifted by 20 pixels right horizontally\r\n\t\t\t//   topRight:20, -15 means topRight position shifted by 20 pixels to right and 15 pixels to top\r\n\t\t\t//You can use +pixels, - pixels. If no sign is provided than + is default.\r\n\t\t\tvar positionType=field.data(\"promptPosition\") || options.promptPosition;\r\n\t\t\tvar shift1=\"\";\r\n\t\t\tvar shift2=\"\";\r\n\t\t\tvar shiftX=0;\r\n\t\t\tvar shiftY=0;\r\n\t\t\tif (typeof(positionType)=='string') {\r\n\t\t\t\t//do we have any position adjustments ?\r\n\t\t\t\tif (positionType.indexOf(\":\")!=-1) {\r\n\t\t\t\t\tshift1=positionType.substring(positionType.indexOf(\":\")+1);\r\n\t\t\t\t\tpositionType=positionType.substring(0,positionType.indexOf(\":\"));\r\n\r\n\t\t\t\t\t//if any advanced positioning will be needed (percents or something else) - parser should be added here\r\n\t\t\t\t\t//for now we use simple parseInt()\r\n\r\n\t\t\t\t\t//do we have second parameter?\r\n\t\t\t\t\tif (shift1.indexOf(\",\") !=-1) {\r\n\t\t\t\t\t\tshift2=shift1.substring(shift1.indexOf(\",\") +1);\r\n\t\t\t\t\t\tshift1=shift1.substring(0,shift1.indexOf(\",\"));\r\n\t\t\t\t\t\tshiftY=parseInt(shift2);\r\n\t\t\t\t\t\tif (isNaN(shiftY)) shiftY=0;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tshiftX=parseInt(shift1);\r\n\t\t\t\t\tif (isNaN(shift1)) shift1=0;\r\n\r\n\t\t\t\t};\r\n\t\t\t};\r\n\r\n\t\t\t\r\n\t\t\tswitch (positionType) {\r\n\t\t\t\tdefault:\r\n\t\t\t\tcase \"topRight\":\r\n\t\t\t\t\tpromptleftPosition +=  fieldLeft + fieldWidth - 30;\r\n\t\t\t\t\tpromptTopPosition +=  fieldTop;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"topLeft\":\r\n\t\t\t\t\tpromptTopPosition +=  fieldTop;\r\n\t\t\t\t\tpromptleftPosition += fieldLeft; \r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"centerRight\":\r\n\t\t\t\t\tpromptTopPosition = fieldTop+4;\r\n\t\t\t\t\tmarginTopSize = 0;\r\n\t\t\t\t\tpromptleftPosition= fieldLeft + field.outerWidth(true)+5;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"centerLeft\":\r\n\t\t\t\t\tpromptleftPosition = fieldLeft - (promptElmt.width() + 2);\r\n\t\t\t\t\tpromptTopPosition = fieldTop+4;\r\n\t\t\t\t\tmarginTopSize = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"bottomLeft\":\r\n\t\t\t\t\tpromptTopPosition = fieldTop + field.height() + 5;\r\n\t\t\t\t\tmarginTopSize = 0;\r\n\t\t\t\t\tpromptleftPosition = fieldLeft;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"bottomRight\":\r\n\t\t\t\t\tpromptleftPosition = fieldLeft + fieldWidth - 30;\r\n\t\t\t\t\tpromptTopPosition =  fieldTop +  field.height() + 5;\r\n\t\t\t\t\tmarginTopSize = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"inline\":\r\n\t\t\t\t\tpromptleftPosition = 0;\r\n\t\t\t\t\tpromptTopPosition = 0;\r\n\t\t\t\t\tmarginTopSize = 0;\r\n\t\t\t};\r\n\r\n\t\t\r\n\r\n\t\t\t//apply adjusments if any\r\n\t\t\tpromptleftPosition += shiftX;\r\n\t\t\tpromptTopPosition  += shiftY;\r\n\r\n\t\t\treturn {\r\n\t\t\t\t\"callerTopPosition\": promptTopPosition + \"px\",\r\n\t\t\t\t\"callerleftPosition\": promptleftPosition + \"px\",\r\n\t\t\t\t\"marginTopSize\": marginTopSize + \"px\"\r\n\t\t\t};\r\n\t\t},\r\n\t\t/**\r\n\t\t* Saves the user options and variables in the form.data\r\n\t\t*\r\n\t\t* @param {jqObject}\r\n\t\t*            form - the form where the user option should be saved\r\n\t\t* @param {Map}\r\n\t\t*            options - the user options\r\n\t\t* @return the user options (extended from the defaults)\r\n\t\t*/\r\n\t\t _saveOptions: function(form, options) {\r\n\r\n\t\t\t // is there a language localisation ?\r\n\t\t\t if ($.validationEngineLanguage)\r\n\t\t\t var allRules = $.validationEngineLanguage.allRules;\r\n\t\t\t else\r\n\t\t\t $.error(\"jQuery.validationEngine rules are not loaded, plz add localization files to the page\");\r\n\t\t\t // --- Internals DO NOT TOUCH or OVERLOAD ---\r\n\t\t\t // validation rules and i18\r\n\t\t\t $.validationEngine.defaults.allrules = allRules;\r\n\r\n\t\t\t var userOptions = $.extend(true,{},$.validationEngine.defaults,options);\r\n\r\n\t\t\t form.data('jqv', userOptions);\r\n\t\t\t return userOptions;\r\n\t\t },\r\n\r\n\t\t /**\r\n\t\t * Removes forbidden characters from class name\r\n\t\t * @param {String} className\r\n\t\t */\r\n\t\t _getClassName: function(className) {\r\n\t\t\t if(className)\r\n\t\t\t\t return className.replace(/:/g, \"_\").replace(/\\./g, \"_\");\r\n\t\t\t\t\t  },\r\n\t\t/**\r\n\t\t * Escape special character for jQuery selector\r\n\t\t * http://totaldev.com/content/escaping-characters-get-valid-jquery-id\r\n\t\t * @param {String} selector\r\n\t\t */\r\n\t\t _jqSelector: function(str){\r\n\t\t\treturn str.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\r\n\t\t},\r\n\t\t/**\r\n\t\t* Conditionally required field\r\n\t\t*\r\n\t\t* @param {jqObject} field\r\n\t\t* @param {Array[String]} rules\r\n\t\t* @param {int} i rules index\r\n\t\t* @param {Map}\r\n\t\t* user options\r\n\t\t* @return an error string if validation failed\r\n\t\t*/\r\n\t\t_condRequired: function(field, rules, i, options) {\r\n\t\t\tvar idx, dependingField;\r\n\r\n\t\t\tfor(idx = (i + 1); idx < rules.length; idx++) {\r\n\t\t\t\tdependingField = jQuery(\"#\" + rules[idx]).first();\r\n\r\n\t\t\t\t/* Use _required for determining wether dependingField has a value.\r\n\t\t\t\t * There is logic there for handling all field types, and default value; so we won't replicate that here\r\n\t\t\t\t * Indicate this special use by setting the last parameter to true so we only validate the dependingField on chackboxes and radio buttons (#462)\r\n\t\t\t\t */\r\n\t\t\t\tif (dependingField.length && methods._required(dependingField, [\"required\"], 0, options, true) == undefined) {\r\n\t\t\t\t\t/* We now know any of the depending fields has a value,\r\n\t\t\t\t\t * so we can validate this field as per normal required code\r\n\t\t\t\t\t */\r\n\t\t\t\t\treturn methods._required(field, [\"required\"], 0, options);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t    _submitButtonClick: function(event) {\r\n\t        var button = $(this);\r\n\t        var form = button.closest('form, .validationEngineContainer');\r\n\t        form.data(\"jqv_submitButton\", button.attr(\"id\"));\r\n\t    }\r\n\t\t  };\r\n\r\n\t /**\r\n\t * Plugin entry point.\r\n\t * You may pass an action as a parameter or a list of options.\r\n\t * if none, the init and attach methods are being called.\r\n\t * Remember: if you pass options, the attached method is NOT called automatically\r\n\t *\r\n\t * @param {String}\r\n\t *            method (optional) action\r\n\t */\r\n\t $.fn.validationEngine = function(method) {\r\n\r\n\t\t var form = $(this);\r\n\t\t if(!form[0]) return form;  // stop here if the form does not exist\r\n\r\n\t\t if (typeof(method) == 'string' && method.charAt(0) != '_' && methods[method]) {\r\n\r\n\t\t\t // make sure init is called once\r\n\t\t\t if(method != \"showPrompt\" && method != \"hide\" && method != \"hideAll\")\r\n\t\t\t methods.init.apply(form);\r\n\r\n\t\t\t return methods[method].apply(form, Array.prototype.slice.call(arguments, 1));\r\n\t\t } else if (typeof method == 'object' || !method) {\r\n\r\n\t\t\t // default constructor with or without arguments\r\n\t\t\t methods.init.apply(form, arguments);\r\n\t\t\t return methods.attach.apply(form);\r\n\t\t } else {\r\n\t\t\t $.error('Method ' + method + ' does not exist in jQuery.validationEngine');\r\n\t\t }\r\n\t};\r\n\r\n\r\n\r\n\t// LEAK GLOBAL OPTIONS\r\n\t$.validationEngine= {fieldIdCounter: 0,defaults:{\r\n\r\n\t\t// Name of the event triggering field validation\r\n\t\tvalidationEventTrigger: \"blur\",\r\n\t\t// Automatically scroll viewport to the first error\r\n\t\tscroll: true,\r\n\t\t// Focus on the first input\r\n\t\tfocusFirstField:true,\r\n\t\t// Show prompts, set to false to disable prompts\r\n\t\tshowPrompts: true,\r\n       // Should we attempt to validate non-visible input fields contained in the form? (Useful in cases of tabbed containers, e.g. jQuery-UI tabs)\r\n       validateNonVisibleFields: false,\r\n\t\t// Opening box position, possible locations are: topLeft,\r\n\t\t// topRight, bottomLeft, centerRight, bottomRight, inline\r\n\t\t// inline gets inserted after the validated field or into an element specified in data-prompt-target\r\n\t\tpromptPosition: \"topRight\",\r\n\t\tbindMethod:\"bind\",\r\n\t\t// internal, automatically set to true when it parse a _ajax rule\r\n\t\tinlineAjax: false,\r\n\t\t// if set to true, the form data is sent asynchronously via ajax to the form.action url (get)\r\n\t\tajaxFormValidation: false,\r\n\t\t// The url to send the submit ajax validation (default to action)\r\n\t\tajaxFormValidationURL: false,\r\n\t\t// HTTP method used for ajax validation\r\n\t\tajaxFormValidationMethod: 'get',\r\n\t\t// Ajax form validation callback method: boolean onComplete(form, status, errors, options)\r\n\t\t// retuns false if the form.submit event needs to be canceled.\r\n\t\tonAjaxFormComplete: $.noop,\r\n\t\t// called right before the ajax call, may return false to cancel\r\n\t\tonBeforeAjaxFormValidation: $.noop,\r\n\t\t// Stops form from submitting and execute function assiciated with it\r\n\t\tonValidationComplete: false,\r\n\r\n\t\t// Used when you have a form fields too close and the errors messages are on top of other disturbing viewing messages\r\n\t\tdoNotShowAllErrosOnSubmit: false,\r\n\t\t// Object where you store custom messages to override the default error messages\r\n\t\tcustom_error_messages:{},\r\n\t\t// true if you want to vind the input fields\r\n\t\tbinded: true,\r\n\t\t// set to true, when the prompt arrow needs to be displayed\r\n\t\tshowArrow: true,\r\n\t\t// did one of the validation fail ? kept global to stop further ajax validations\r\n\t\tisError: false,\r\n\t\t// Limit how many displayed errors a field can have\r\n\t\tmaxErrorsPerField: false,\r\n\t\t\r\n\t\t// Caches field validation status, typically only bad status are created.\r\n\t\t// the array is used during ajax form validation to detect issues early and prevent an expensive submit\r\n\t\tajaxValidCache: {},\r\n\t\t// Auto update prompt position after window resize\r\n\t\tautoPositionUpdate: false,\r\n\r\n\t\tInvalidFields: [],\r\n\t\tonFieldSuccess: false,\r\n\t\tonFieldFailure: false,\r\n\t\tonSuccess: false,\r\n\t\tonFailure: false,\r\n\t\tvalidateAttribute: \"class\",\r\n\t\taddSuccessCssClassToField: \"\",\r\n\t\taddFailureCssClassToField: \"\",\r\n\t\t\r\n\t\t// Auto-hide prompt\r\n\t\tautoHidePrompt: false,\r\n\t\t// Delay before auto-hide\r\n\t\tautoHideDelay: 10000,\r\n\t\t// Fade out duration while hiding the validations\r\n\t\tfadeDuration: 0.3,\r\n\t // Use Prettify select library\r\n\t prettySelect: false,\r\n\t // Add css class on prompt\r\n\t addPromptClass : \"\",\r\n\t // Custom ID uses prefix\r\n\t usePrefix: \"\",\r\n\t // Custom ID uses suffix\r\n\t useSuffix: \"\",\r\n\t // Only show one message per error prompt\r\n\t showOneMessage: false\r\n\t}};\r\n\t$(function(){$.validationEngine.defaults.promptPosition = methods.isRTL()?'topLeft':\"topRight\"});\r\n})(jQuery);","var googleMapsStyles = [\n  {\n    \"featureType\": \"administrative.land_parcel\",\n    \"elementType\": \"all\",\n    \"stylers\": [\n    {\n      \"visibility\": \"off\"\n    }\n    ]\n  },\n  {\n    \"featureType\": \"landscape.man_made\",\n    \"elementType\": \"all\",\n    \"stylers\": [\n      {\n        \"visibility\": \"off\"\n      }\n    ]\n  },\n  {\n    \"featureType\": \"poi\",\n    \"elementType\": \"labels\",\n    \"stylers\": [\n      {\n        \"visibility\": \"off\"\n      }\n    ]\n  },\n  {\n    \"featureType\": \"road\",\n    \"elementType\": \"labels\",\n    \"stylers\": [\n      {\n        \"visibility\": \"simplified\"\n      },\n      {\n        \"lightness\": 20\n      }\n    ]\n  },\n  {\n    \"featureType\": \"road.highway\",\n    \"elementType\": \"geometry\",\n    \"stylers\": [\n      {\n        \"hue\": \"#f49935\"\n      }\n    ]\n  },\n  {\n    \"featureType\": \"road.highway\",\n    \"elementType\": \"labels\",\n    \"stylers\": [\n      {\n        \"visibility\": \"simplified\"\n      }\n    ]\n  },\n  {\n    \"featureType\": \"road.arterial\",\n    \"elementType\": \"geometry\",\n    \"stylers\": [\n      {\n        \"hue\": \"#fad959\"\n      }\n    ]\n  },\n  {\n    \"featureType\": \"road.arterial\",\n    \"elementType\": \"labels\",\n    \"stylers\": [\n      {\n        \"visibility\": \"off\"\n      }\n    ]\n  },\n  {\n    \"featureType\": \"road.local\",\n    \"elementType\": \"geometry\",\n    \"stylers\": [\n      {\n        \"visibility\": \"simplified\"\n      }\n    ]\n  },\n  {\n    \"featureType\": \"road.local\",\n    \"elementType\": \"labels\",\n    \"stylers\": [\n      {\n        \"visibility\": \"simplified\"\n      }\n    ]\n  },\n  {\n    \"featureType\": \"transit\",\n    \"elementType\": \"all\",\n    \"stylers\": [\n      {\n        \"visibility\": \"off\"\n      }\n    ]\n  },\n  {\n    \"featureType\": \"water\",\n    \"elementType\": \"all\",\n    \"stylers\": [\n      {\n        \"hue\": \"#a1cdfc\"\n      },\n      {\n        \"saturation\": 30\n      },\n      {\n        \"lightness\": 49\n      }\n    ]\n  }\n];\n","$(function() {\n\n  if(!Modernizr.touch) {\n    $('.validate').validationEngine();\n  } else {\n    $('.validate').validationEngine({scroll: false});\n  }\n\n  var mapData = {\n    title: 'Esign',\n    lat: 51.0325538,\n    long: 3.7333816,\n    externUrl: 'https://www.google.be/maps/place/Esign+-+Web+%26+Graphics/@51.0325538,3.7333816,19z/data=!3m1!4b1!4m5!3m4!1s0x47c373970c763623:0xde317546f86febc9!8m2!3d51.0325538!4d3.7339288'\n  };\n\n  var map = addContactGoogleMaps('map', mapData.lat, mapData.long);\n  addContactGoogleMapsMarker(map, mapData.lat, mapData.long, mapData.title, mapData.externUrl);\n\n});\n\nfunction addContactGoogleMaps(container, latitude, longitude) {\n\n  var zoom = 15,\n      disable = true,\n      scroll = false,\n      styledMap = new google.maps.StyledMapType(googleMapsStyles, { name: 'Styled Map' }),\n      mapCenter = new google.maps.LatLng(latitude, longitude),\n      mapOptions = {\n        zoom: zoom,\n        panControl: true,\n        zoomControl: disable,\n        scaleControl: true,\n        mapTypeControl: false,\n        streetViewControl: false,\n        overviewMapControl: false,\n        minZoom : 2,\n        scrollwheel: scroll,\n        center: mapCenter,\n        mapTypeId: google.maps.MapTypeId.ROADMAP\n      },\n      map = new google.maps.Map(document.getElementById(container), mapOptions);\n\n  map.mapTypes.set('map_style', styledMap);\n  map.setMapTypeId('map_style');\n\n  google.maps.event.addDomListener(window, 'resize', function() {\n    map.setCenter(mapCenter);\n  });\n\n  return map;\n}\n\nfunction addContactGoogleMapsMarker(map, latitude, longitude, title, externUrl) {\n  var myLatlng = new google.maps.LatLng(latitude, longitude),\n      markerIcon = {\n          url: baseUrl + 'assets/images/marker.png',\n          size: new google.maps.Size(100, 128),\n          origin: new google.maps.Point(0, 0),\n          anchor: new google.maps.Point(25, 64),\n        scaledSize: new google.maps.Size(50, 64)\n      },\n      marker = new google.maps.Marker({\n        position: myLatlng,\n        map: map,\n        icon: markerIcon\n      });\n\n  google.maps.event.addListener(marker, 'click', function() {\n    window.open(externUrl, '_blank');\n  });\n\n  return marker;\n}\n"]}